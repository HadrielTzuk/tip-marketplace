from EmailUtils import get_unicode_str
from ExchangeActions import extract_action_parameter, init_manager, is_rtl, add_rtl_html_divs_to_body
from ExchangeManager import SiemplifyMessageDictKeys, DEFAULT_RESOLVED_BODY
from ExchangeCommon import ExchangeCommon
from ScriptResult import EXECUTION_STATE_COMPLETED, EXECUTION_STATE_INPROGRESS, EXECUTION_STATE_FAILED
from SiemplifyAction import SiemplifyAction
from SiemplifyUtils import convert_dict_to_json_result_dict, output_handler
import sys
import json
import uuid
from constants import INTEGRATION_NAME, SEND_EMAIL_AND_WAIT_SCRIPT_NAME, PARAMETERS_DEFAULT_DELIMITER,\
    EXCHLIB_MESSAGE_ID_KEY
from ExchangeUtilsManager import convert_comma_separated_to_list


# maximum retry count in case of network error
MAX_RETRY = 5

# Product Decision.
ATTACHMENTS_EXTENSION = ".unsafe"
RESULT_ID_KEY = 'result_id'


def start_operation(manager, generate_mail_id, subject, content, send_to, cc, bcc):
    """
    Sends email using provided details
    :param manager: ExchangeManager object.
    :param generate_mail_id: {bool} Defines if message_id should be generated by the servers.
    :param subject: {str} Email subject
    :param content: {str} Email contents
    :param send_to: {str} Comma-separated list of emails to be included to TO
    :param cc: {str} Comma-separated list of emails to be included to CC
    :param bcc: {str} Comma-separated list of emails to be included to BCC
    :return: {tuple} output message, json result, execution state
    """
    siemplify_id = uuid.uuid4()

    if not generate_mail_id:
        # Mail ID generation is not supported - create unique subject to identify the email later
        subject = "{}-{}".format(subject, siemplify_id)

    result = manager.send_mail_html_embedded_photos(
        to_addresses=send_to,
        subject=subject,
        html_body=content,
        cc=cc,
        bcc=bcc,
        generate_mail_id=generate_mail_id)

    msg_id = result.message_id if result else None
    status = EXECUTION_STATE_INPROGRESS
    output_message = "Mail sent successfully"
    result_id = msg_id if generate_mail_id else str(siemplify_id)
    result_value = json.dumps({RESULT_ID_KEY: result_id})
    return output_message, result_value, status


def query_operation_status(siemplify, manager, recipients_string):
    """
    Get email reply by provided data.
    :param siemplify: SiemplifyAction object.
    :param manager: ExchangeManager object.
    :param recipients_string: {str} Comma-separated list of recipients
    :return: {tuple} output message, json result, execution state
    """
    recipients_responses = {}
    ec = ExchangeCommon(siemplify.LOGGER, manager)

    recipients_list = [r.strip() for r in recipients_string.split(PARAMETERS_DEFAULT_DELIMITER) if
                       r] if recipients_string else []
    # Additional data contains message_id, which we pass from the SendEmail part
    additional_data_json = extract_action_parameter(siemplify=siemplify, param_name="additional_data",
                                                    default_value='{}', is_mandatory=True)
    additional_data = json.loads(additional_data_json).get(RESULT_ID_KEY)
    reply_folder = extract_action_parameter(siemplify=siemplify, param_name="Folder to Check for Reply")
    fetch_response_attachments = extract_action_parameter(siemplify=siemplify, param_name="Fetch Response Attachments",
                                                          input_type=bool, default_value=False)
    generate_mail_id = manager.is_writable_mail_id_supported()
    reply_folder_list = convert_comma_separated_to_list(reply_folder)
    messages_dicts = []

    for item in reply_folder_list:
        if generate_mail_id:
            # Mail ID was generated and passed in additional data. Filter by it.
            messages_dicts.extend(manager.receive_mail(reply_to=additional_data, mark_as_read=True,
                                                       siemplify_result=True, folder_name=item, set_folder=True))
        else:
            # Mail ID is not supported - filter by unique subject generated by the action and passed as additional data.
            messages_dicts.extend(manager.receive_mail(subject_filter=additional_data, mark_as_read=True,
                                                       siemplify_result=True, folder_name=item, set_folder=True))

    siemplify.LOGGER.info("Received {} reply messages.".format(len(messages_dicts)))
    siemplify.LOGGER.info("Running on recipients: {}".format(PARAMETERS_DEFAULT_DELIMITER.join(recipients_list)))

    for recipient in recipients_list:
        siemplify.LOGGER.info("Running on recipient: {}".format(recipient))
        message = ec.get_user_first_valid_message(sender=recipient, messages=messages_dicts)
        siemplify.LOGGER.info("Got message for recipient: {}".format(recipient))
        recipients_responses[recipient] = message

    siemplify.LOGGER.info(recipients_responses)
    first_valid_response = next(((recipient, message) for recipient, message in list(recipients_responses.items())
                                 if message), None)

    if not first_valid_response:
        if generate_mail_id:
            output_message = "Continuing...waiting for response, searching IN-REPLY-TO {}".format(additional_data)
        else:
            output_message = "Continuing...waiting for response, searching SUBJECT containing {}".format(additional_data)

        siemplify.LOGGER.info(output_message)
        result_value = json.dumps({RESULT_ID_KEY: additional_data})
        status = EXECUTION_STATE_INPROGRESS

    else:
        recipient, message = first_valid_response[0], first_valid_response[1]

        siemplify.LOGGER.info("Received response from {}: {}".format(recipient, message))

        # Manage attachments
        if fetch_response_attachments:
            try:
                message_attachments = message[SiemplifyMessageDictKeys.ATTACHMENTS_KEY]
                siemplify.LOGGER.info("Found {} attachments for message with ID: {}".format(
                    len(message_attachments),
                    message[EXCHLIB_MESSAGE_ID_KEY]
                ))

                for file_name, file_content in list(message_attachments.items()):
                    siemplify.result.add_attachment(title="{0}_{1}".format(file_name, message[EXCHLIB_MESSAGE_ID_KEY]),
                                                    filename="{0}_{1}{2}".format(message[EXCHLIB_MESSAGE_ID_KEY],
                                                                                 file_name,
                                                                                 ATTACHMENTS_EXTENSION),
                                                    file_contents=file_content)
                    siemplify.LOGGER.info("Attached file with name '{}' from message with ID '{}'".format(
                        file_name,
                        message[EXCHLIB_MESSAGE_ID_KEY]
                    ))
            except Exception as err:
                error_message = "Failed fetching attachments for Message ID: {0}.".format(message[EXCHLIB_MESSAGE_ID_KEY])
                siemplify.LOGGER.error(error_message)
                siemplify.LOGGER.exception(err)

        json_result = convert_dict_to_json_result_dict({recipient: message})
        siemplify.result.add_result_json(json_result)
        output_message, result_value = build_result_objects(siemplify, message)
        status = EXECUTION_STATE_COMPLETED

    return output_message, result_value, status


@output_handler
def main(is_first_run):
    siemplify = SiemplifyAction()
    siemplify.script_name = SEND_EMAIL_AND_WAIT_SCRIPT_NAME
    mode = "Main" if is_first_run else "QueryState"
    result_value = ""

    siemplify.LOGGER.info("----------------- {} - Param Init -----------------".format(mode))

    subject = extract_action_parameter(siemplify=siemplify, param_name="Subject", is_mandatory=True)
    content = extract_action_parameter(siemplify=siemplify, param_name="Mail content", is_mandatory=True)
    send_to = extract_action_parameter(siemplify=siemplify, param_name="Send to", is_mandatory=True)
    cc = extract_action_parameter(siemplify=siemplify, param_name="CC")
    bcc = extract_action_parameter(siemplify=siemplify, param_name="BCC")

    siemplify.LOGGER.info("----------------- {} - Started -----------------".format(mode))

    # If the body is rtl send as html message
    if is_rtl(content):
        content = add_rtl_html_divs_to_body(content)

    try:
        # Create new exchange manager instance
        em = init_manager(siemplify, INTEGRATION_NAME)
        generate_mail_id = em.is_writable_mail_id_supported()

        if is_first_run:
            output_message, result_value, status = start_operation(em, generate_mail_id, subject, content, send_to,
                                                                   cc, bcc)
        else:
            output_message, result_value, status = query_operation_status(siemplify, em, send_to)


    except Exception as e:
        siemplify.LOGGER.error("General error performing action {}".format(SEND_EMAIL_AND_WAIT_SCRIPT_NAME))
        siemplify.LOGGER.exception(e)
        status = EXECUTION_STATE_FAILED
        output_message = "An error occurred while running action: {}".format(e)

        additional_data_json = extract_action_parameter(siemplify=siemplify, param_name="additional_data",
                                                        default_value='{}')
        output_message, result_value, status = ExchangeCommon.prevent_async_action_fail_in_case_of_network_error(e,
                                                                                                                 additional_data_json,
                                                                                                                 MAX_RETRY,
                                                                                                                 output_message,
                                                                                                                 result_value,
                                                                                                                 status)

    siemplify.LOGGER.info("----------------- Main - Finished -----------------")
    siemplify.LOGGER.info("Status: {}".format(status))
    siemplify.LOGGER.info("Result Value: {}".format(result_value))
    siemplify.LOGGER.info("Output Message: {}".format(output_message))

    siemplify.end(output_message, result_value, status)


def build_result_objects(siemplify, message_dict):
    """
    Generate output message from received message.
    output_message should be first email body (full thread) + handle unicode/str encoding as needed
    :param siemplify: {SiemplifyAction} SiemplifyAction instance.
    :param message_dict: {dict} Received message dict.
    :return: {string} Action output.
    """
    body = ""

    try:
        body = get_unicode_str(message_dict[SiemplifyMessageDictKeys.RESOLVED_BODY_KEY])
        reply_section_index = body.index("From:")
        result_value = body[:reply_section_index]
    except Exception as e:
        siemplify.LOGGER.error("Failed to extract response content without the forwarding part")
        siemplify.LOGGER.exception(e)
        result_value = message_dict.get(SiemplifyMessageDictKeys.RESOLVED_BODY_KEY)

    output_message = "Response:\n{0}".format(body)

    return output_message, result_value


if __name__ == "__main__":
    is_first_run = len(sys.argv) < 3 or sys.argv[2] == "True"
    main(is_first_run)
