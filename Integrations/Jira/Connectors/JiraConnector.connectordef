{
    "CreationTimeUnixTimeInMs": 1533109458129,
    "Creator": "Admin",
    "Description": "Fetch issues from Jira to Siemplify",
    "Id": -1,
    "Integration": "Jira",
    "IsConnectorRulesSupported": false,
    "IsCustom": false,
    "IsEnabled": true,
    "MappingRules": [],
    "ModificationTimeUnixTimeInMs": 1533109458129,
    "Name": "Jira Connector",
    "Parameters": [
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1533109458129,
            "DefaultValue": "device_product",
            "Description": "The field name used to determine the device product",
            "Id": -1,
            "IsMandatory": true,
            "IsAdvanced": true,
            "Mode": 0,
            "ModificationTimeUnixTimeInMs": 1533109458129,
            "Name": "DeviceProductField",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1533109458129,
            "DefaultValue": "issuetype_name",
            "Description": "The field name used to determine the event name (sub-type)",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 0,
            "ModificationTimeUnixTimeInMs": 1533109458129,
            "Name": "EventClassId",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1533109458129,
            "DefaultValue": 180,
            "Description": "The timeout limit (in seconds) for the python process running current script",
            "Id": -1,
            "IsMandatory": true,
            "IsAdvanced": true,
            "Mode": 0,
            "ModificationTimeUnixTimeInMs": 1533109458129,
            "Name": "PythonProcessTimeout",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1533109458129,
            "DefaultValue": "https://{jira_address}",
            "Description": "The API root of the JIRA instance",
            "Id": -1,
            "IsMandatory": true,
            "IsAdvanced": false,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1533109458129,
            "Name": "Api Root",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1533109458129,
            "DefaultValue": "",
            "Description": "",
            "Id": -1,
            "IsMandatory": true,
            "IsAdvanced": false,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1533109458129,
            "Name": "Username",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1533109458129,
            "DefaultValue": "",
            "Description": "",
            "Id": -1,
            "IsMandatory": true,
            "IsAdvanced": false,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1533109458129,
            "Name": "Api Token",
            "Type": 3
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1533109458129,
            "DefaultValue": true,
            "Description": "Use Jira project as environment else use Environment Field Name as environment.",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": false,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1533109458129,
            "Name": "Use Jira Project as Environment",
            "Type": 0
        },
        {
           "Name": "Environment Field Name",
           "Type": 2,
           "DefaultValue": "",
           "IsMandatory": false,
           "IsAdvanced": true,
           "Description": "Describes the name of the field where the environment name is stored. If the environment field isn't found, the environment is the default environment.",
           "ConnectorDefinitionId": -1,
           "CreationTimeUnixTimeInMs": 1612974139532,
           "Id": -1,
           "Mode":2,
           "ModificationTimeUnixTimeInMs": 1612974139532
        },
        {
           "Name": "Environment Regex Pattern",
           "Type": 2,
           "DefaultValue": ".*",
           "IsMandatory": false,
           "IsAdvanced": true,
           "Description": "A regex pattern to run on the value found in the \"Environment Field Name\" field. Default is .* to catch all and return the value unchanged. Used to allow the user to manipulate the environment field via regex logic. If the regex pattern is null or empty, or the environment value is null, the final environment result is the default environment.",
           "ConnectorDefinitionId": -1,
           "CreationTimeUnixTimeInMs": 1612974139532,
           "Id": -1,
           "Mode":2,
           "ModificationTimeUnixTimeInMs": 1612974139532
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1533109458129,
            "DefaultValue": 5,
            "Description": "Max number of days backwards to pull alerts from",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": false,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1533109458129,
            "Name": "Days Backwards",
            "Type": 1
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1533109458129,
            "DefaultValue": 10,
            "Description": "Max tickets to fetch and process in one connector cycle",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": false,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1533109458129,
            "Name": "Max Tickets Per Cycle",
            "Type": 1
        },
        {
			"ConnectorDefinitionId": -1,
			"CreationTimeUnixTimeInMs": 1532871487965,
			"DefaultValue": false,
			"Description": "If enabled, verify the SSL certificate for the connection to Jira server is valid.",
			"Id": -1,
			"IsMandatory": true,
            "IsAdvanced": false,
			"Mode": 2,
			"ModificationTimeUnixTimeInMs": 1532871487965,
			"Name": "Verify SSL",
			"Type": 0
		},
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1533109458129,
            "DefaultValue": "",
            "Description": "Project names separated by comma",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1533109458129,
            "Name": "Project Names",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1533109458129,
            "DefaultValue": "",
            "Description": "Issue statuses separated by comma",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1533109458129,
            "Name": "Issue Statuses",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1533109458129,
            "DefaultValue": "",
            "Description": "Users full names separated by comma",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1533109458129,
            "Name": "Assignees",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1533109458129,
            "DefaultValue": "",
            "Description": "Issue types separated by comma",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1533109458129,
            "Name": "Issue Types",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1533109458129,
            "DefaultValue": "",
            "Description": "Issue priorities separated by comma",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1533109458129,
            "Name": "Issue Priorities",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1533109458129,
            "DefaultValue": "",
            "Description": "Issue components separated by comma",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1533109458129,
            "Name": "Issue Components",
            "Type": 2
        },
        {
            "CreationTimeUnixTimeInMs": 1574099687000,
            "Name": "Proxy Server Address",
            "ModificationTimeUnixTimeInMs": 1574099687000,
            "Type": 2,
            "DefaultValue": "",
            "Description": "The address of the proxy server to use.",
            "ConnectorDefinitionId": -1,
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2
        },
        {
            "CreationTimeUnixTimeInMs": 1574099687000,
            "Name": "Proxy Username",
            "ModificationTimeUnixTimeInMs": 1574099687000,
            "Type": 2,
            "DefaultValue": "",
            "Description": "The proxy username to authenticate with.",
            "ConnectorDefinitionId": -1,
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2
        },
        {
            "CreationTimeUnixTimeInMs": 1525167465721,
            "Name": "Proxy Password",
            "ModificationTimeUnixTimeInMs": 1525167465721,
            "Type": 3,
            "DefaultValue": "",
            "Description": "The proxy password to authenticate with.",
            "ConnectorDefinitionId": -1,
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2
        }
    ],
    "ProductToVisualFamilyRecords": [],
    "Rules": [],
    "Script": "#============================================================================#\n# title           :JirsConnector.py\n# description     :This Module contain all Jira connector functionality\n# author          :zivh@siemplify.co\n# date            :31-07-2018\n# python_version  :2.7\n# ============================================================================#\n\n# ============================= IMPORTS ===================================== #\nimport sys\nimport uuid\nimport datetime\nimport os\nimport json\nimport arrow\n\nfrom SiemplifyUtils import utc_now, convert_string_to_datetime, dict_to_flat, convert_datetime_to_unix_time, convert_string_to_unix_time\nfrom SiemplifyConnectors import CaseInfo, SiemplifyConnectorExecution\nfrom JiraManager import JiraManager\n\n# ============================== CONSTS ===================================== #\nPRODUCT = VENDOR = \"Atlassian\"\nDEFAULT_DAYS_BACKWARDS = 2\nMAX_TICKETS_PER_CYCLE = 10\nRULE_GENERATOR = DEFAULT_NAME = 'Jira'\nMSG_ID_ERROR_MSG = \"Can't get issue key\"\n\nJIRA_TIME_FORMAT = '%Y/%m/%d %H:%M'\nFILE_IDS_HOURS_LIMIT = 24\nIDS_FILE = \"ids.json\"\n\nCRITICAL_PRIORITY = 100\nHIGH_PRIORITY = 80\nMEDIUM_PRIORITY = 60\nLOW_PRIORITY = 40\nPRIORITY_MAPPING = {'High': HIGH_PRIORITY, 'Medium': MEDIUM_PRIORITY, 'Low': LOW_PRIORITY, 'Highest': CRITICAL_PRIORITY}\n# ============================= CLASSES ===================================== #\n\n\nclass JiraConnectorException(Exception):\n    \"\"\"\n    Jira Connector Exception\n    \"\"\"\n    pass\n\n\nclass JiraConnector(object):\n\n    def __init__(self, connector_scope, jira_manager, max_tickets_per_cycle):\n        self.connector_scope = connector_scope\n        self.logger = connector_scope.LOGGER\n        self.jira_manager = jira_manager\n        self.max_tickets_per_cycle = max_tickets_per_cycle\n\n    @staticmethod\n    def validate_timestamp(last_run_timestamp, offset):\n        \"\"\"\n        Validate timestamp in range\n        :param last_run_timestamp: {datetime} last run timestamp\n        :param offset: {datetime} last run timestamp\n        :return: {datetime} if first run, return current time minus offset time, else return timestamp from file\n        \"\"\"\n        current_time = utc_now()\n        # Check if first run\n        if current_time - last_run_timestamp > datetime.timedelta(days=offset):\n            return current_time - datetime.timedelta(days=offset)\n        else:\n            return last_run_timestamp\n\n    def read_ids(self, ids_file_path):\n        \"\"\"\n        Read existing alerts IDs from ids file.\n        :param ids_file_path: {str} The path of the ids file.\n        :return: {dict} Dict of the ids ({id: id's entrance timestamp})\n        \"\"\"\n        if not os.path.exists(ids_file_path):\n            return {}\n\n        try:\n            with open(ids_file_path, 'r') as f:\n                return json.loads(f.read())\n        except Exception as e:\n            self.logger.error(\"Unable to read ids file: {}\".format(str(e)))\n            self.logger.exception(e)\n            return {}\n\n    @staticmethod\n    def write_ids(ids_file_path, ids):\n        \"\"\"\n        Write ids to the ids file\n        :param ids_file_path: {str} The path of the ids file.\n        :param ids: {dict} The ids to write to the file\n        \"\"\"\n        if not os.path.exists(os.path.dirname(ids_file_path)):\n            os.makedirs(os.path.dirname(ids_file_path))\n\n        with open(ids_file_path, 'w') as f:\n            f.write(json.dumps(ids))\n\n    @staticmethod\n    def filter_old_ids(ids):\n        \"\"\"\n        Filter ids that are older than IDS_HOURS_LIMIT hours\n        :param ids: {dict} The ids to filter\n        :return: {dict} The filtered ids\n        \"\"\"\n        filtered_ids = {}\n        for alert_id, timestamp in ids.items():\n            if timestamp > arrow.utcnow().shift(hours=-FILE_IDS_HOURS_LIMIT).timestamp:\n                filtered_ids[alert_id] = timestamp\n\n        return filtered_ids\n\n    def get_issues(self, last_run, project_name):\n        \"\"\"\n        Get tickets from Jira since last success time.\n        :param last_run: {datetime} last run timestamp\n        :param project_name: {string} jira project name\n        :return: {list} of found tickets {Issues Objects}\n\n        \"\"\"\n        # Jira valid formats include: 'yyyy/MM/dd HH:mm', 'yyyy-MM-dd HH:mm', 'yyyy/MM/dd', 'yyyy-MM-dd'\n        last_time_jira = last_run.strftime(JIRA_TIME_FORMAT)\n\n        tickets_keys = []\n        tickets = []\n\n        try:\n            # Get tickets since last success time.\n            # created_from: {string} starting issue creation date\n            tickets_keys = self.jira_manager.list_issues(project_key=project_name, created_from=last_time_jira)\n\n        except Exception as e:\n            self.logger.error(\"Failed to fetch issues keys\")\n            self.logger.exception(e)\n\n        # Read already existing alerts ids\n        old_ids = self.read_ids(\n            os.path.join(self.connector_scope.run_folder, IDS_FILE))\n\n        # Filter out old ids (older than 24 hours)\n        old_ids = self.filter_old_ids(old_ids)\n\n        # Sort tickets list so the first ticket id will be the oldest\n        tickets_keys = list(reversed(tickets_keys))\n\n        # Tickets limit per cycle - Default - The 10 oldest issues (Ticket ids sorted by times)\n        for ticket in tickets_keys[:self.max_tickets_per_cycle]:\n            try:\n                ticket_details = self.jira_manager.get_issue_by_key(ticket)\n                # Filter out tickets by last run time and by ids\n                if self.is_valid_ticket_time(last_run, ticket_details) and ticket not in old_ids:\n                    tickets.append(ticket_details)\n\n            except Exception as e:\n                self.logger.error(\"Failed to retrieve issue data. Error message: {}\".format(str(e)))\n                self.logger.exception(e)\n\n        self.logger.info(\"Found {0} issues since {1}.\".format(len(tickets), unicode(last_time_jira).encode('utf-8')))\n\n        # Add the added alerts to ids vault\n        for ticket in tickets:\n            old_ids.update({ticket.key: arrow.utcnow().timestamp})\n\n        self.write_ids(os.path.join(self.connector_scope.run_folder, IDS_FILE), old_ids)\n\n        return tickets\n\n    @staticmethod\n    def is_valid_ticket_time(last_run_time, ticket_object):\n        \"\"\"\n        Compare ticket time to connector last run time to make sure tickets are not taken more than once.\n        Base on the Jira Api, tickets fetch with time zone\n        :param last_run_time: {datetime} last execution time from file\n        :param ticket_object: {Issue object}\n        :return: {Boolean}\n        \"\"\"\n        # compare full dates\n        ticket_time = convert_string_to_datetime(ticket_object.raw['fields'].get('created'))\n        # Checking if ticket is already taken, if yes - ticket is not valid.\n        if ticket_time <= last_run_time:\n            return False\n        return True\n\n    @staticmethod\n    def create_event(ticket_object):\n        \"\"\"\n        Create events from issue data\n        :param ticket_object: {Issue Object} All ticket data\n        :return: event {dict} one event from the issue data\n        \"\"\"\n        event_details = dict_to_flat(ticket_object.raw['fields'])\n        # Remove empty keys (empty strings, keep 0 values)\n        event_details = dict([(key, value) for key, value in event_details.items() if str(value).strip()])\n\n        return event_details\n\n    @staticmethod\n    def map_priority(jira_priority):\n        \"\"\"\n        Mapping Jira priority to siemplify priority\n        :param jira_priority: {string} (Highest, High, Medium, Low)\n        :return: {int} (40=low, 60=medium, 80=high, 100=critical)\n        \"\"\"\n        for j_priority, matching_siemplify_priority in PRIORITY_MAPPING.items():\n            if j_priority == jira_priority:\n                return matching_siemplify_priority\n        return LOW_PRIORITY\n\n    def create_case_info(self, ticket_object, event, environment):\n        \"\"\"\n        Get alerts from Issues\n        :param ticket_object: {Issue Object} An issue data\n        :param event: {dict} one event from the issue data\n        :param environment:\n        :return: {CaseInfo} case\n        \"\"\"\n        # Validate issue key exists\n        try:\n            ticket_key = ticket_object.key\n        except Exception as e:\n            ticket_key = '{0}-{1}'.format(MSG_ID_ERROR_MSG, str(uuid.uuid4()))\n            self.logger.error(\"Found issue, cannot get its key. {0}\".format(str(e)))\n            self.logger.exception(e)\n\n        case_info = CaseInfo()\n        self.logger.info(\"Creating Case for Issue {}\".format(ticket_key))\n\n        # Create the CaseInfo\n        try:\n            try:\n                case_info.name = ticket_object.key\n            except Exception as e:\n                self.logger.error(\"{0}. {1}\".format(MSG_ID_ERROR_MSG, e))\n                case_info.name = DEFAULT_NAME\n\n            case_info.rule_generator = RULE_GENERATOR\n\n            # save time in unix (milliseconds).\n            case_info.start_time = convert_string_to_unix_time(ticket_object.raw['fields'].get('created')) if \\\n                ticket_object.raw['fields'].get('created') else 1\n            case_info.end_time = case_info.start_time\n\n            case_info.identifier = ticket_key\n            case_info.ticket_id = case_info.identifier\n            # Priority mapped from jira values to siemplify values\n            case_info.priority = self.map_priority(ticket_object.raw['fields'].get('priority').get('name'))\n            case_info.device_vendor = VENDOR\n            case_info.device_product = PRODUCT\n            case_info.display_id = case_info.identifier\n            case_info.environment = environment\n            case_info.events = [event]\n\n        except KeyError as e:\n            raise KeyError(\"Mandatory key is missing: {}. Skipping Issue.\".format(unicode(str(e).encode('utf-8'))))\n\n        return case_info\n\n\ndef main(is_test=False):\n    connector_scope = SiemplifyConnectorExecution()\n    output_variables = {}\n    log_items = []\n    connector_scope.LOGGER.info(\"=======Starting Jira Connector.=======\")\n\n    try:\n        # Configurations.\n        api_root = connector_scope.parameters['Api Root']\n        username = connector_scope.parameters['Username']\n        password = connector_scope.parameters['Password']\n        jira_manager = JiraManager(api_root, username, password)\n\n        first_run_timestamp = int(connector_scope.parameters.get('Days Backwards', DEFAULT_DAYS_BACKWARDS))\n        max_tickets_per_cycle = int(\n            connector_scope.parameters.get('Max Tickets Per Cycle', MAX_TICKETS_PER_CYCLE))\n        projects_keys = connector_scope.whitelist\n        environment = connector_scope.context.connector_info.environment\n\n        jira_connector = JiraConnector(connector_scope, jira_manager, max_tickets_per_cycle)\n\n        # Fix first time run\n        last_run_time = connector_scope.fetch_timestamp(datetime_format=True)\n        last_calculated_run_time = jira_connector.validate_timestamp(last_run_time, first_run_timestamp)\n        connector_scope.LOGGER.info(\n            \"Calculating connector last run time. Last run time is: {0}\".format(last_calculated_run_time))\n\n        # Fix projects keys format - ['TIP', 'SE FulFillment'] should be \"'TIP', 'SE FulFillment'\"\n        projects_keys = \", \".join(\"'{}'\".format(project) for project in projects_keys)\n\n        # Get alerts\n        connector_scope.LOGGER.info(\"Collecting Tickets for {0} projects.\".format(projects_keys))\n\n        tickets = jira_connector.get_issues(last_calculated_run_time, projects_keys)\n\n        cases = []\n        for ticket in tickets:\n            try:\n                # Create security event\n                event = jira_connector.create_event(ticket)\n\n                # Create case info\n                case = jira_connector.create_case_info(ticket, event, environment)\n\n                is_overflow = False\n                try:\n                    # Check if alert overflow\n                    is_overflow = connector_scope.is_overflowed_alert(\n                        environment=case.environment,\n                        alert_identifier=str(case.ticket_id),\n                        alert_name=str(case.rule_generator),\n                        product=str(case.device_product)\n                    )\n                except Exception as e:\n                    connector_scope.LOGGER.error(\"Check if alert is overflow failed. Error: {0}.\".format(e))\n\n                if is_overflow:\n                    # Skipping this alert (and dot ingest it to siemplify)\n                    connector_scope.LOGGER.info(\"{alert_name}-{alert_identifier}-{environment}-{product} found as overflow alert. Skipping\"\n                                                .format(alert_name=str(case.rule_generator),\n                                                        alert_identifier=str(case.ticket_id),\n                                                        environment=environment,\n                                                        product=str(case.device_product)))\n                else:\n                    # Ingest the case to siemplify\n                    cases.append(case)\n\n            except Exception as e:\n                connector_scope.LOGGER.error(\"Failed to create CaseInfo\")\n                connector_scope.LOGGER.error(\"Error Message: {}\".format(str(e)))\n                connector_scope.LOGGER.exception(e)\n\n        connector_scope.LOGGER.info(\"Completed processing issues.\")\n\n        # Get last successful execution time.\n        if cases:\n            # Sort the cases by the end time of each case.\n            cases = sorted(cases, key=lambda case: case.end_time)\n            # Last execution time is set to the newest message time\n            new_last_run_time = cases[-1].end_time\n        else:\n            # last_calculated_run_time is datetime object. Convert it to milliseconds timestamp.\n            new_last_run_time = convert_datetime_to_unix_time(last_calculated_run_time)\n\n        connector_scope.LOGGER.info(\"Create {} cases.\".format(len(cases)))\n\n        if not is_test:\n            # update last execution time\n            connector_scope.save_timestamp(new_timestamp=new_last_run_time)\n            # Return data\n            connector_scope.return_package(cases, output_variables, log_items)\n        else:\n            # Return data\n            connector_scope.return_test_result(True, {})\n\n        connector_scope.LOGGER.info(\"=======Jira Connector Finish.=======\")\n\n    except Exception as e:\n        connector_scope.LOGGER.error(str(e))\n        connector_scope.LOGGER.exception(e)\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2 or sys.argv[1] == 'True':\n        print \"Main execution started\"\n        main()\n    else:\n        print \"Test execution started\"\n        main(is_test=True)\n",
    "SimulationUseCases": {
        "CasesForUseCase": [],
        "UseCaseName": null
    },
    "Version": 1
}