# ==============================================================================
# title           :McAfeeTIEDXLManager.py
# description     :This Module contain all McAfee DXL & TIE logic.
# author          :avital@siemplify.co
# date            :23-05-18
# python_version  :2.7
# libraries       : dxlclient, dxltieclient, arrow
# requirements    : DXL certificates. Can be generated by following the tutorial:
#                   https://opendxl.github.io/opendxl-client-python/pydoc/basiccliprovisioning.html
# product_version : 1.0
# ==============================================================================

# =====================================
#              IMPORTS                #
# =====================================
import requests
from dxlclient.client_config import DxlClientConfig
from dxlclient.client import DxlClient
from dxlclient.broker import Broker
from dxltieclient import TieClient
from dxltieclient.constants import HashType, TrustLevel
import arrow

# =====================================
#             PAYLOADS                #
# =====================================

PROVIDERS = {
    '1': 'Global Threat Intelligence (GTI)',
    '3': 'McAfee Threat Intelligence Exchange', # 'Enterprise reputation',
    '5': 'Advanced Threat Defense (ATD)',
    '7': 'Web Gateway (MWG)'
}

TRUST_LEVELS = {
    'NOT_SET': '0',
    'KNOWN_MALICIOUS': '1',
    'MOST_LIKELY_MALICIOUS': '15',
    'MIGHT_BE_MALICIOUS': '30',
    'UNKNOWN': '50',
    'MIGHT_BE_TRUSTED': '70',
    'MOST_LIKELY_TRUSTED': '85',
    'KNOWN_TRUSTED': '99',
    'KNOWN_TRUSTED_INSTALLER': '100'
}

HASH_TYPE_KEYS = {
    'md5': HashType.MD5,
    'sha1': HashType.SHA1,
    'sha256': HashType.SHA256
}

MD5 = 'md5'
SHA256 = 'sha256'
SHA1 = 'sha1'
VENDOR_NAME = 'McAfee Threat Intelligence Exchange'
MAX_TRUST_LEVEL = 101
DATE_FORMAT = 'YYYY-MM-DD HH:mm:ss ZZ'

# =====================================
#             CONSTANTS               #
# =====================================


# =====================================
#              CLASSES                #
# =====================================


class McAfeeTIEDXLManagerError(Exception):
    """
    McAfee TIE DXL Exception
    """
    pass


class McAfeeTIEDXLManager(object):
    def __init__(self, server_address, broker_ca_bundle_path, cert_file_path, private_key_path):
        # Create config
        config = DxlClientConfig(broker_ca_bundle=broker_ca_bundle_path,
                                 cert_file=cert_file_path,
                                 private_key=private_key_path,
                                 brokers=[Broker.parse(server_address)]
                                 )

        # Set connectivity params
        config.connect_retries = 1
        config.reconnect_delay = 1
        config.reconnect_delay_max = 10

        # Create the DXL client
        self.dxl_client = DxlClient(config)

        # Connect to the fabric
        self.dxl_client.connect()

        # Create the McAfee Threat Intelligence Exchange (TIE) client
        self.tie_client = TieClient(self.dxl_client)

    def get_file_reputation(self, filehash):
        """
        Get the reputations for the specified hash (MD5, SHA1 & SHA256 only)
        :param filehash: {str} The file hash
        :return: {list} The list of found reputations
        """
        hash_type = self.get_hash_type(filehash)
        hash_type_key = HASH_TYPE_KEYS.get(hash_type)

        if not hash_type_key:
            raise McAfeeTIEDXLManagerError("Unsupported hash type - {}".format(hash_type))

        hash_param = {hash_type_key: filehash}

        res = self.tie_client.get_file_reputation(hash_param)

        reputations = [self.parse_reputation(reputation) for reputation in res.values()]
        return reputations

    def set_file_reputation(self, filehash, trust_level, filename=None, comment=None):
        """
        Sets the "Enterprise" reputation (trust level) of a specified file.
        :param filehash: {str} Hash of the file to set. Supports MD5 SHA1 & SHA256
        :param trust_level: {str} The new trust level for the file. One of the following:
            NOT_SET, KNOWN_MALICIOUS, MOST_LIKELY_MALICIOUS, MIGHT_BE_MALICIOUS, UNKNOWN,
            MIGHT_BE_TRUSTED, MOST_LIKELY_TRUSTED, KNOWN_TRUSTED, KNOWN_TRUSTED_INSTALLER.
        :param filename: {str} A file name to associate with the file (optional)
        :param comment: {str} A comment to associate with the file (optional)
        :return: {bool} True if successful, exception otherwise.
        """
        # find trust_level key
        trust_level_key = TRUST_LEVELS.get(trust_level)

        if not trust_level_key:
            raise McAfeeTIEDXLManagerError(
                "Unsupported trust level - {}".format(trust_level))

        hash_type = self.get_hash_type(filehash)
        hash_type_key = HASH_TYPE_KEYS.get(hash_type)

        if not hash_type_key:
            raise McAfeeTIEDXLManagerError(
                "Unsupported hash type - {}".format(hash_type))

        hash_param = {hash_type_key: filehash}

        try:
            # Set the reputation
            self.tie_client.set_file_reputation(trust_level_key, hash_param,
                                                filename, comment)
            return True

        except Exception as e:
            raise McAfeeTIEDXLManagerError("Unable to set reputation for {}: {}".format(filehash, str(e)))

    def get_file_references(self, filehash):
        """
        Get the references of a file
        :param filehash: {str} The file's hash
        :return: {list} The found references
        """
        hash_type = self.get_hash_type(filehash)
        hash_type_key = HASH_TYPE_KEYS.get(hash_type)

        if not hash_type_key:
            raise McAfeeTIEDXLManagerError(
                "Unsupported hash type - {}".format(hash_type))

        hash_param = {hash_type_key: filehash}

        references = self.tie_client.get_file_first_references(hash_param)

        return [self.parse_reference(ref) for ref in references]

    def get_worst_trust_level(self, reputations):
        """
        Get the worst trust level of a file from given reputations
        :param reputations: {list} The reputations of the file (parsed reputations)
        :return: {dict} The info of the worst trust level
        """
        trust_level = MAX_TRUST_LEVEL
        vendor = VENDOR_NAME
        first_contact = 0
        verbose_trust_level = ''
        provider_id = 0

        # Get the minimum trust level (the worst among all of the reputations)
        for rep in reputations:
            rep_trust_level = int(rep.get('Trust Level', MAX_TRUST_LEVEL))

            if rep_trust_level and rep_trust_level < trust_level:
                trust_level = rep_trust_level
                vendor = rep.get('Verbose Provider')
                first_contact = rep.get('First Contact')
                verbose_trust_level = rep.get('Verbose Trust level')
                provider_id = rep.get('Provider ID')

        if trust_level == MAX_TRUST_LEVEL:
            # No trust_level found or trust level is NOT_SET
            return {
                'trust_level': 0,
                'vendor': vendor,
                'first_contact': first_contact,
                'verbose_trust_level': 'NOT_SET',
                'provider_id': provider_id
            }

        return {
            'trust_level': trust_level,
            'vendor': vendor,
            'first_contact': first_contact,
            'verbose_trust_level': verbose_trust_level,
            'provider_id': provider_id
        }


    def prepare_enrichment_repustations(self, reputations):
        
        reputations_processed = []
        for rep in reputations:
            provider = rep.get('Verbose Provider').replace(" ","_")
            
            rep_dict = {
                '{}_trust_level'.format(provider): int(rep.get('Trust Level')),
                '{}_vendor'.format(provider): rep.get('Verbose Provider'),
                '{}_first_contact'.format(provider): rep.get('First Contact'),
                '{}_verbose_trust_level'.format(provider): rep.get('Verbose Trust level'),
                '{}_provider_id'.format(provider): rep.get('Provider ID')
            }

            reputations_processed.append(rep_dict)
            
        return reputations_processed


    @staticmethod
    def get_hash_type(filehash):
        """
        Checks whether has is MD5 or SHA256
        :param filehash: {string} the file hash to identify
        :return: {string} MD5 or SHA256
        """
        if len(filehash) == 32:
            return MD5
        elif len(filehash) == 64:
            return SHA256
        elif len(filehash) == 40:
            return SHA1

    @staticmethod
    def parse_reputation(rep):
        """
        Parse raw reputation to human readable form
        :param rep: {dict} The reputation
        :return: {dict} The parsed reputation
        """
        # get trust level
        trust_level = str(rep.get('trustLevel'))
        verbose_trust_level = None

        for trust_level_name, trust_level_value in TRUST_LEVELS.iteritems():
            if trust_level_value == trust_level:
                verbose_trust_level = trust_level_name

        # get provider
        provider_id = rep.get('providerId')
        provider = PROVIDERS.get(unicode(provider_id).encode('utf-8'), unicode(provider_id).encode('utf-8'))

        # rep.get('createDate') is unixtime in seconds.
        res = {
            'Trust Level': trust_level,
            'Verbose Trust level': verbose_trust_level,
            'Provider ID': provider_id,
            'Verbose Provider': provider,
            'First Contact': arrow.get(rep.get('createDate')).format(DATE_FORMAT)
        }

        return res

    @staticmethod
    def parse_reference(reference):
        """
        Parse raw reference to human readable form
        :param reference: {dict} The reference
        :return: {dict} The parsed reference
        """
        agent_guid = reference.get('agentGuid')
        # reference.get('date') is unixtime in seconds.
        return {
            'File Reference Date': arrow.get(reference.get('date')).format(DATE_FORMAT),
            'Agent GUID': agent_guid.replace('{', '').replace('}', '')
        }

    @staticmethod
    def construct_csv(results):
        """
        Constructs a csv from results
        :param results: The results to add to the csv (results are list of flat dicts)
        :return: {list} csv formatted list
        """
        csv_output = []
        headers = reduce(set.union, map(set, map(dict.keys, results)))

        csv_output.append(",".join(map(str, headers)))

        for result in results:
            csv_output.append(
                ",".join([s.replace(',', ' ') for s in
                          map(str, [unicode(result.get(h, None)).encode('utf-8') for h in headers])]))

        return csv_output


