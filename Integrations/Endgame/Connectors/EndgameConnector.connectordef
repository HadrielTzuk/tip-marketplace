{
    "CreationTimeUnixTimeInMs": 1560353647180, 
    "Creator": "Admin", 
    "Description": "", 
    "Id": -1,
    "Integration": "Endgame", 
    "IsConnectorRulesSupported": true, 
    "IsCustom": false, 
    "IsEnabled": true, 
    "MappingRules": [], 
    "ModificationTimeUnixTimeInMs": 1560353647180, 
    "Name": "Endgame Connector", 
    "Parameters": [
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1560353647228, 
            "DefaultValue": "device_product", 
            "Description": "The field name used to determine the device product", 
            "Id": 0, 
            "IsMandatory": true, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1560353647228, 
            "Name": "DeviceProductField", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1560353647230, 
            "DefaultValue": "event_name", 
            "Description": "The field name used to determine the event name (sub-type)", 
            "Id": 0, 
            "IsMandatory": false, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1560353647230, 
            "Name": "EventClassId", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1560353647231, 
            "DefaultValue": "30", 
            "Description": "The timeout limit (in seconds) for the python process running current script", 
            "Id": 0, 
            "IsMandatory": true, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1560353647231, 
            "Name": "PythonProcessTimeout", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1560353647231, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": 0, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1560353647231, 
            "Name": "API Root", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1560353647233, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": 0, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1560353647233, 
            "Name": "Username", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1560353647233, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": 0, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1560353647233, 
            "Name": "Password", 
            "Type": 3
        }, 
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1560353647234, 
            "DefaultValue": "false", 
            "Description": "", 
            "Id": 0, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1560353647234, 
            "Name": "Verify SSL", 
            "Type": 0
        }, 
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1560353647234, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": 0, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1560353647234, 
            "Name": "Max Days Backwards", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1560353647235, 
            "DefaultValue": null, 
            "Description": "If defined - connector will extract the environment from the specified event field. You can manipulate the field data using the Regex pattern field to extract specific string. In case the the extracted environment field and Siemplify environment name are not equal - you can map them in the map.json that is auto-generated on the first run, inside the <run-folder>.<run-folder> = C:\\Siemplify_Server\\Scripting\\SiemplifyConnectorExecution<Connector_Folder>", 
            "Id": 0, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1560353647235, 
            "Name": "Environment Field Name", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": null, 
            "Description": "If defined - the connector will implement the specific RegEx pattern on the data from \"envirnment field\" to extract specific string. For example - extract domain from sender's address: \"(?<=@)(\\S+$)\"", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Environment Regex Pattern", 
            "Type": 1
        }, 
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1560353647235, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": 0, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1560353647235, 
            "Name": "Alerts Count Limit", 
            "Type": 2
        }, 
        {
            "CreationTimeUnixTimeInMs": 1574099687000, 
            "Name": "Proxy Server Address", 
            "ModificationTimeUnixTimeInMs": 1574099687000, 
            "Type": 2, 
            "DefaultValue": null, 
            "Description": "The address of the proxy server to use.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }, 
        {
            "CreationTimeUnixTimeInMs": 1574099687000, 
            "Name": "Proxy Username", 
            "ModificationTimeUnixTimeInMs": 1574099687000, 
            "Type": 2, 
            "DefaultValue": null, 
            "Description": "The proxy username to authenticate with.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }, 
        {
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Proxy Password", 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Type": 3, 
            "DefaultValue": null, 
            "Description": "The proxy password to authenticate with.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }
    ], 
    "ProductToVisualFamilyRecords": [], 
    "Rules": [], 
    "Script": "# ============================================================================#\n# title           :EndgameConnector.py\n# description     :This Module contain all Endgame connector functionality\n# author          :zivh@siemplify.co\n# date            :12-06-19\n# python_version  :2.7\n# ============================================================================#\n\n# ============================= IMPORTS ===================================== #\nimport sys\nimport re\nimport arrow\nfrom SiemplifyUtils import dict_to_flat, utc_now, convert_datetime_to_unix_time, unix_now, convert_string_to_unix_time\nfrom SiemplifyConnectors import CaseInfo, SiemplifyConnectorExecution\nfrom EndgameManager import EndgameManager\n\n# ============================== CONSTS ===================================== #\nDEFAULT_PRODUCT = DEFAULT_VENDOR = \"Endgame\"\nALERTS_LIMIT = 20\nTIMEZONE = \"UTC\"\nTIME_FORMAT = \"%Y-%m-%dT%H:%M:%SZ\"  # ISO-8601 datetime\nTIMESTAMP_FILE = \"timestamp.stmp\"\n\n# ============================== PAYLOAD ===================================== #\n\n\n# ============================= CLASSES ===================================== #\n\n\nclass EndgameConnectorException(Exception):\n    \"\"\"\n    Endgame Exception\n    \"\"\"\n    pass\n\n\nclass EndgameConnector(object):\n    \"\"\"\n    Endgame Connector\n    \"\"\"\n\n    def __init__(self, connector_scope, endgame_manager, environment_field_name):\n        self.connector_scope = connector_scope\n        self.logger = connector_scope.LOGGER\n        self.endgame_manager = endgame_manager\n        self.environment_field_name = environment_field_name\n\n    @staticmethod\n    def validate_timestamp(last_run_timestamp, offset):\n        \"\"\"\n        Validate timestamp in range\n        :param last_run_timestamp: {arrow datetime} last run timestamp\n        :param offset: {datetime} last run timestamp\n        :return: {datetime} if first run, return current time minus offset time, else return timestamp from file\n        \"\"\"\n        # Check if first run\n        if arrow.get(last_run_timestamp).shift(days=offset) < arrow.utcnow():\n            return arrow.utcnow().shift(days=-offset)\n        else:\n            return last_run_timestamp\n\n    @staticmethod\n    def get_priority(alert):\n        \"\"\"\n        Translate the priority of Endgame to Siemplify priority\n        :param alert: {dict} An Endgame alert\n        :return: {int} The matching priority\n        \"\"\"\n        alert_risk = alert.get(\"severity\")\n        if \"high\" == alert_risk:\n            return 100\n        elif 'low' == alert_risk:\n            return 40\n\n        return 40\n\n    def get_alerts(self, last_run, max_alerts_per_cycle):\n        \"\"\"\n        Fetch alerts from Endgame from last run\n        :param last_run: {str} The time to fetch the alerts from (%Y-%m-%dT%H:%M:%SZ)\n        :param max_alerts_per_cycle: {int} Max num of alerts to detch in one time.\n        :return: {list} List of found alerts\n        \"\"\"\n        all_alerts = self.endgame_manager.get_alerts(end_timestamp=last_run)\n\n        # Cut the alerts to max_alerts_per_cycle\n        sorted_alerts = sorted(all_alerts, key=lambda alert: arrow.get(alert['created_at']))\n        if len(sorted_alerts) > max_alerts_per_cycle:\n            self.connector_scope.LOGGER.info(\"Slicing to {} alerts.\".format(max_alerts_per_cycle))\n            sorted_alerts = sorted_alerts[:max_alerts_per_cycle]\n\n        return sorted_alerts\n\n    def create_event(self, alert):\n        \"\"\"\n        Create event from Endgame alert\n        :param alert: {dict} An Endgame alert\n        :return: {dict} event details\n        \"\"\"\n        self.logger.info(\"Creating security event\")\n        event_details = {\n            \"Alert Type\": re.sub(r'([A-Z])', r' \\1', alert.get('type')) or None,\n            \"Status\": alert.get(\"archived\") or \"Open\",\n            \"Assigned To\": alert.get(\"assigned_to\").get(\"full_name\") or \"Unassigned\",\n            \"Severity\": alert.get(\"severity\") or None,\n            \"Date Created\": alert.get('created_at') or None,\n            \"Endpoint Name\": alert.get(\"endpoint\").get('name') or None,\n            \"Endpoint IP Address\": alert.get(\"endpoint\").get('ip_address') or None,\n            \"Endpoint Status\": alert.get(\"endpoint\").get('status') or None,\n            \"Endpoint OS\": alert.get(\"endpoint\").get('display_operating_system') or None\n        }\n        event_details.update(dict_to_flat(alert.get('data')))\n\n        # remove none items\n        event_details = {k: v for k, v in event_details.items() if v is not None}\n        return event_details\n\n    def create_case_info(self, alert):\n        \"\"\"\n        Create CaseInfo object from Endgame alert\n        :param alert: {dict} An Endgame alert\n        :return: {CaseInfo} The newly created case\n        \"\"\"\n        self.logger.info(\n            \"Creating Case for Alert {}\".format(unicode(alert['id']).encode(\"utf-8\")))\n\n        try:\n            # Create the CaseInfo\n            case_info = CaseInfo()\n\n            # split by uppercase\n            case_info.name = re.sub(r'([A-Z])', r' \\1', alert.get('type'))\n\n            case_info.ticket_id = alert['id']\n            case_info.display_id = alert['id']\n            case_info.rule_generator = case_info.name\n            case_info.device_vendor = DEFAULT_VENDOR\n            case_info.device_product = DEFAULT_PRODUCT\n            case_info.priority = self.get_priority(alert)\n\n            try:\n                # Verify timezone (MS) --> this is UTC TIME\n                alert_time = arrow.get(alert.get('created_at', 1)).timestamp * 1000\n            except Exception as e:\n                self.logger.error(\"Unable to get alert time: {}\".format(str(e)))\n                self.logger.exception(e)\n                alert_time = 1\n\n            case_info.start_time = alert_time\n            case_info.end_time = alert_time\n\n            if self.environment_field_name:\n                case_info.environment = alert.get(self.environment_field_name, self.connector_scope.context.connector_info.environment)\n\n        except KeyError as e:\n            raise KeyError(\"Mandatory key is missing: {}\".format(str(e)))\n\n        # Split the alert to events and flatten them\n        try:\n            event = self.create_event(alert)\n        except Exception as e:\n            self.logger.error(\"Unable to create an event from Endgame alert: {}\".format(str(e)))\n            event = {}\n\n        case_info.events = [event]\n\n        return case_info\n\n\ndef main(test_handler=False):\n    \"\"\"\n    Main execution - Endgame Connector\n    \"\"\"\n    connector_scope = SiemplifyConnectorExecution()\n    connector_scope.script_name = 'Endgame Connector'\n    output_variables = {}\n    log_items = []\n\n    if test_handler:\n        connector_scope.LOGGER.info(\"========== Starting Connector Test ==========.\")\n    else:\n        connector_scope.LOGGER.info(\"========== Starting Connector ==========.\")\n\n    try:\n        connector_scope.LOGGER.info(\"Connecting to Endgame\")\n        api_root = connector_scope.parameters['API Root']\n        username = connector_scope.parameters['Username']\n        password = connector_scope.parameters['Password']\n        use_ssl = connector_scope.parameters.get('Use SSL', 'False').lower() == 'true'\n        offset = int(connector_scope.parameters['Max Days Backwards'])\n        environment_field_name = connector_scope.parameters['Environment Field Name']\n        alerts_limit = int(connector_scope.parameters.get(\n            'Alerts Count Limit')) if connector_scope.parameters.get(\n            'Alerts Count Limit') else ALERTS_LIMIT\n\n        endgame_manager = EndgameManager(api_root, username=username, password=password, use_ssl=use_ssl)\n        endgame_connector = EndgameConnector(connector_scope, endgame_manager, environment_field_name)\n\n        # Validate timezone\n        last_run = endgame_connector.validate_timestamp(\n            connector_scope.fetch_timestamp(datetime_format=True), offset)\n        last_run = last_run.strftime(TIME_FORMAT)\n\n        # Set current time for next run\n        current_time = unix_now()\n\n        # Get alerts from Endgame\n        connector_scope.LOGGER.info(\"Collecting alerts from Endgame since {0}.\".format(last_run))\n        alerts = endgame_connector.get_alerts(last_run, alerts_limit)\n        connector_scope.LOGGER.info(\"Found {} alerts\".format(len(alerts)))\n\n        # Construct CaseInfo from alerts\n        cases = []\n\n        if test_handler:\n            alerts = alerts[-1:]\n\n        for alert in alerts:\n            try:\n                connector_scope.LOGGER.info(\n                    \"Processing alert {}\".format(\n                        unicode(alert['id']).encode(\"utf-8\")))\n\n                case = endgame_connector.create_case_info(alert)\n                is_overflow = False\n\n                try:\n                    is_overflow = connector_scope.is_overflowed_alert(\n                        environment=case.environment,\n                        alert_identifier=str(case.ticket_id),\n                        alert_name=str(case.rule_generator),\n                        product=str(case.device_product)\n                    )\n\n                except Exception as e:\n                    connector_scope.LOGGER.error(\n                        \"Failed to detect overflow for Alert {}\".format(\n                            unicode(alert['data']['id']).encode(\"utf-8\")))\n                    connector_scope.LOGGER.exception(e)\n\n                if not is_overflow:\n                    cases.append(case)\n\n                else:\n                    connector_scope.LOGGER.warn(\n                        \"Overflowed on Alert {}\".format(unicode(alert['id']).encode(\"utf-8\")))\n\n            except Exception as e:\n                # Failed to build CaseInfo for alert\n                connector_scope.LOGGER.error(\n                    \"Failed to create CaseInfo for alert {}: {}\".format(alert['id'], str(e))\n                )\n                connector_scope.LOGGER.error(\n                    \"Error Message: {}\".format(str(e)))\n\n                if test_handler:\n                    raise e\n\n        connector_scope.LOGGER.info(\n            \"Completed. Found {} cases.\".format(len(cases)))\n\n        if test_handler:\n            connector_scope.LOGGER.info(\"--------- Test completed. ------------\")\n\n        if cases:\n            new_last_run_time = convert_string_to_unix_time(alerts[-1][\"created_at\"])\n        else:\n            new_last_run_time = current_time\n\n        connector_scope.save_timestamp(new_timestamp=new_last_run_time)\n\n        # Return data\n        connector_scope.return_package(cases, output_variables, log_items)\n\n    except Exception as e:\n        connector_scope.LOGGER.error(str(e))\n        connector_scope.LOGGER.exception(e)\n        if test_handler:\n            raise e\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2 or sys.argv[1] == 'True':\n        print \"Main execution started\"\n        main(test_handler=False)\n    else:\n        print \"Test execution started\"\n        main(test_handler=True)\n", 
    "SimulationUseCases": {
        "CasesForUseCase": [], 
        "UseCaseName": null
    }, 
    "Version": 2
}