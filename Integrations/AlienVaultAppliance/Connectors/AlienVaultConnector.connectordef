{
    "CreationTimeUnixTimeInMs": 1526568773024, 
    "Creator": "admin", 
    "Description": "", 
    "Id": -1, 
    "Integration": "AlienVaultAppliance", 
    "IsConnectorRulesSupported": false, 
    "IsCustom": false, 
    "IsEnabled": true, 
    "MappingRules": [], 
    "ModificationTimeUnixTimeInMs": 1526568773024, 
    "Name": "AlienVault USM Appliance Connector", 
    "Parameters": [
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526568773024, 
            "DefaultValue": "device_product", 
            "Description": "The field name used to determine the device product", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1526568773024, 
            "Name": "DeviceProductField", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526568773024, 
            "DefaultValue": "name", 
            "Description": "The field name used to determine the event name (sub-type)", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1526568773024, 
            "Name": "EventClassId", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526568773024, 
            "DefaultValue": "60", 
            "Description": "The timeout limit (in seconds) for the python process running current script", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1526568773024, 
            "Name": "PythonProcessTimeout", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526568773024, 
            "DefaultValue": null, 
            "Description": "e.g. https://<instance>.alienvault.com", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1526568773024, 
            "Name": "Api Root", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526568773024, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1526568773024, 
            "Name": "Username", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526568773024, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1526568773024, 
            "Name": "Password", 
            "Type": 3
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526568773024, 
            "DefaultValue": "10", 
            "Description": "Limit the number of events per alert. e.g. 10", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1526568773024, 
            "Name": "Max Events Per Alert", 
            "Type": 1
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526568773024, 
            "DefaultValue": "1", 
            "Description": "This field is used in the connector first running cycle and determine the connector start time. e.g. 3", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1526568773024, 
            "Name": "Max Days Backwards", 
            "Type": 1
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526568773024, 
            "DefaultValue": "10", 
            "Description": "Limit the number of alerts in every cycle. e.g. 10", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1526568773024, 
            "Name": "Max Alerts Per Cycle", 
            "Type": 1
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526568773024, 
            "DefaultValue": "UTC", 
            "Description": "The timezone configured in the AlienVault's, ex. UTC, Asia/Jerusalem etc.", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1526568773024, 
            "Name": "Server Timezone", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526568773024, 
            "DefaultValue": null, 
            "Description": "The name of the environment's field. e.g. AlienVault Sensor", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1526568773024, 
            "Name": "Environment Field Name", 
            "Type": 2
        }, 
        {
            "CreationTimeUnixTimeInMs": 1574099687000, 
            "Name": "Proxy Server Address", 
            "ModificationTimeUnixTimeInMs": 1574099687000, 
            "Type": 2, 
            "DefaultValue": null, 
            "Description": "The address of the proxy server to use.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }, 
        {
            "CreationTimeUnixTimeInMs": 1574099687000, 
            "Name": "Proxy Username", 
            "ModificationTimeUnixTimeInMs": 1574099687000, 
            "Type": 2, 
            "DefaultValue": null, 
            "Description": "The proxy username to authenticate with.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }, 
        {
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Proxy Password", 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Type": 3, 
            "DefaultValue": null, 
            "Description": "The proxy password to authenticate with.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }
    ], 
    "ProductToVisualFamilyRecords": [], 
    "Rules": [], 
    "Script": "# ============================================================================#\n# title           :AlienVaultConnector.py\n# description     :This Module contain all AlienVault connector functionality\n# author          :avital@siemplify.co\n# date            :17-05-2018\n# python_version  :2.7\n# ============================================================================#\n\n# ============================= IMPORTS ===================================== #\n\nimport sys\nimport os\nimport json\nsys.path.append(r\"C:\\repos\\SIEMplify\\Dynamo-1.97\\Server\\Services\\Siemplify.Server.Service\\bin\\Debug\\Scripting\\PythonSDK\")\n\nimport dateparser\nimport arrow\nfrom SiemplifyUtils import dict_to_flat, utc_now, convert_datetime_to_unix_time\nfrom SiemplifyConnectors import CaseInfo, SiemplifyConnectorExecution\nfrom AlienVaultManager import AlienVaultManager\nfrom SiemplifyMock import SiemplifyConnectorMock\n# ============================== CONSTS ===================================== #\nDEFAULT_PRODUCT = DEFAULT_VENDOR = \"AlienVault USM\"\nDEFAULT_NAME = \"Alient Vault Default Alert Name\"\nALERTS_LIMIT = 20\nTIMEZONE = \"UTC\"\nTIME_FORMAT = \"%Y-%m-%d\"\nTIMESTAMP_FILE = \"timestamp.stmp\"\nIDS_FILE = \"ids.json\"\n\n# ============================= CLASSES ===================================== #\n\nclass AlienVaultConnector(object):\n    \"\"\"\n    AlienVault Connector\n    \"\"\"\n\n    def __init__(self, connector_scope, alienvault_manager):\n        self.connector_scope = connector_scope\n        self.logger = connector_scope.LOGGER\n        self.alienvault_manager = alienvault_manager\n\n    def read_ids(self, ids_file_path):\n        if not os.path.exists(ids_file_path):\n            return {}\n\n        try:\n            with open(ids_file_path, 'r') as f:\n                return json.loads(f.read())\n        except Exception as e:\n            self.logger.error(\"Unable to read ids file: {}\".format(str(e)))\n            self.logger._log.exception(e)\n            return {}\n\n    def write_ids(self, ids_file_path, ids):\n        if not os.path.exists(os.path.dirname(ids_file_path)):\n            os.makedirs(os.path.dirname(ids_file_path))\n\n        with open(ids_file_path, 'w') as f:\n            return f.write(json.dumps(ids))\n\n    def filter_old_ids(self, ids):\n        filtered_ids = {}\n        for alert_id, timestamp in ids.items():\n            if  timestamp > arrow.utcnow().shift(hours=-24).timestamp:\n                filtered_ids[alert_id] = timestamp\n\n        return filtered_ids\n\n    @staticmethod\n    def validate_timestamp(last_run_timestamp, offset):\n        \"\"\"\n        Validate timestamp in range\n        :param last_run_timestamp: {arrow datetime} last run timestamp\n        :param offset: {datetime} last run timestamp\n        :return: {datetime} if first run, return current time minus offset time, else return timestamp from file\n        \"\"\"\n        # Check if first run\n        if last_run_timestamp.shift(days=offset) < arrow.utcnow():\n            return arrow.utcnow().shift(days=-offset)\n        else:\n            return last_run_timestamp\n\n    def get_alerts(self, last_run, max_alerts_per_cycle):\n        \"\"\"\n        Fetch alerts from AlienVault from last run\n        :param last_run: {arrow object} The time to fetch the alerts from\n        :return: {list} List of found alerts\n        \"\"\"\n        last_run_timestamp = last_run.strftime(TIME_FORMAT)\n        current_timestamp = arrow.utcnow()\n        self.logger.info(\"Getching alerts from {}\".format(last_run))\n\n        # TODO: Validate timestamp\n        all_alerts = self.alienvault_manager.get_alarms(last_run_timestamp, current_timestamp.strftime(TIME_FORMAT))\n\n        alerts = []\n\n        # Read already existing alerts ids\n        old_ids = self.read_ids(\n            os.path.join(self.connector_scope.run_folder, IDS_FILE))\n\n        # Filter out old ids (older than 24 hours)\n        old_ids = self.filter_old_ids(old_ids)\n\n        # Filter out old alerts by last run time and by ids vault\n        for alert in all_alerts:\n            if self.parse_date(alert.get(\"Date\", 0)) > last_run.timestamp \\\n                    and alert[\"Id\"] not in old_ids:\n                alerts.append(alert)\n\n        # Cut the alerts to max_alerts_per_cycle\n        alerts = sorted(alerts, key=lambda alert: self.parse_date(alert.get('Date', 0)))[:max_alerts_per_cycle]\n\n        # Add the added alerts to ids vault\n        for alert in alerts:\n            old_ids.update({alert['Id']: current_timestamp.timestamp})\n\n        self.write_ids(os.path.join(self.connector_scope.run_folder, IDS_FILE), old_ids)\n\n        return alerts\n\n    @staticmethod\n    def parse_date(timestamp):\n        try:\n            return arrow.get(timestamp).timestamp\n        except Exception:\n            try:\n                return arrow.get(dateparser.parse(\n                    \"{} ago {}\".format(timestamp, TIMEZONE))).timestamp\n            except Exception:\n                return 0\n\n    @staticmethod\n    def get_priority(alert):\n        alert_risk = int(alert.get(\"Risk\"), 0)\n        if 4 <= alert_risk:\n            return 100\n        elif 3 <= alert_risk:\n            return 80\n        elif 2 <= alert_risk:\n            return 60\n        elif 1 <= alert_risk:\n            return 40\n\n        return 0\n\n    def create_case_info(self, alert, max_events_per_alert):\n        \"\"\"\n        Create CaseInfo object from AlienVault alert\n        :param alert: {dict} An ES alert\n        :return: {CaseInfo} The newly created case\n        \"\"\"\n        self.logger.info(\n            \"Creating Case for Alert {}\".format(unicode(alert['Id']).encode(\"utf-8\")))\n\n        try:\n            # Create the CaseInfo\n            case_info = CaseInfo()\n\n            try:\n                if alert.get(\"Destination\") and alert[\"Destination\"].get(\n                        \"Hostname\"):\n                    name = \"{} - {} - {}\".format(alert['Intent'], alert[\"Method\"],\n                                             alert[\"Destination\"][\"Hostname\"])\n                else:\n                    name = \"{} - {}\".format(alert['Intent'], alert[\"Method\"])\n\n            except Exception as e:\n                self.logger.error(\n                    \"Unable to construct alert name: {}\".format(str(e)))\n                self.logger._log.exception(e)\n                name = DEFAULT_NAME\n\n            case_info.name = name\n            case_info.ticket_id = alert['Id']\n\n            case_info.rule_generator = name\n            case_info.display_id = alert['Id']\n            case_info.device_vendor = DEFAULT_VENDOR\n            case_info.device_product = DEFAULT_PRODUCT\n            case_info.priority = self.get_priority(alert)\n            case_info.source_system_name = \"Custom\"\n\n        except KeyError as e:\n            raise KeyError(\"Mandatory key is missing: {}\".format(str(e)))\n\n        events = []\n        self.logger.info(\"Fetching first {} events of {}\".format(max_events_per_alert, alert[\"Id\"]))\n        try:\n            for event_id in self.alienvault_manager.get_events_ids(alert[\"Id\"])[:max_events_per_alert]:\n                try:\n                    self.logger.info(\"Fetching event {}\".format(event_id))\n                    event = self.alienvault_manager.get_event_info(event_id)\n                    event[\"Id\"] = event_id\n                    events.append(event)\n                except Exception as e:\n                    self.logger.error(\"Couldn't get event info for event {}: {}\".format(event_id, str(e)))\n                    self.logger._log.exception(e)\n\n        except Exception as e:\n            self.logger.error(\n                \"Unable to get events for alert {}: {}\".format(alert[\"Id\"], str(e)))\n            self.logger._log.exception(e)\n\n        alert_time = 0\n        flat_events = []\n\n        self.logger.info(\"Processing events of {}\".format(alert[\"Id\"]))\n        for event in events:\n            try:\n                self.logger.info(\"Processing event {} - {}\".format(event[\"Id\"], event.get(\"Name\")))\n                event[\"device_product\"] = event.get(\"Data Source Name\", DEFAULT_PRODUCT)\n                event[\"device_vendor\"] = DEFAULT_VENDOR\n                event[\"Date\"] = self.parse_date(event.get('Date', 0))\n\n                if event.get(\"Category\").lower() == \"alarm\":\n                    # The event is the alarm itself\n                    try:\n                        alert_time = arrow.get(event.get(\"Date\", 0)).timestamp\n                    except Exception as e:\n                        self.logger.error(\"Unable to get alarm time of alert {}: {}\".format(alert[\"Id\"]), str(e))\n                        self.logger._log.exception(e)\n\n                case_info.environment = event.get(\n                    \"AlienVault Sensor\") if not event.get(\n                    \"AlienVault Sensor\") == \"Unknown\" else self.connector_scope.context.connector_info.environment\n\n                flat_events.append(dict_to_flat(event))\n\n            except Exception as e:\n                self.logger.error(\n                    \"Unable to get event data and flatten event {}: {}\".format(\n                        event[\"Id\"], \"\"), str(e))\n                self.logger._log.exception(e)\n\n        case_info.events = flat_events\n        case_info.start_time = alert_time\n        case_info.end_time = alert_time\n\n        return case_info\n\n\ndef test():\n    \"\"\"\n    Test execution - AlienVault Connector\n    \"\"\"\n    connector_scope = SiemplifyConnectorExecution()\n    connector_scope.script_name = 'AlienVault Connector'\n    result_params = {}\n    result_value = True\n\n    connector_scope.LOGGER.info(\"========== Starting Connector Test ==========.\")\n\n    connector_scope.LOGGER.info(\"Testing connection to AlienVault\")\n    api_root = connector_scope.parameters['Api Root']\n    username = connector_scope.parameters['Username']\n    password = connector_scope.parameters['Password']\n    max_events_per_alert = int(connector_scope.parameters['Max Events Per Alert'])\n    max_alert_per_cycle = int(connector_scope.parameters['Max Alerts Per Cycle'])\n    offset = int(connector_scope.parameters['Max Days Backwards'])\n\n    alienvault_manager = AlienVaultManager(api_root, username, password)\n\n    connector_scope.LOGGER.info(\"Connection is successful.\")\n    result_params[\"Connection\"] = \"Successful\"\n\n    alienvault_connector = AlienVaultConnector(connector_scope,\n                                               alienvault_manager)\n\n    # Todo: Validate timezone\n    last_run = alienvault_connector.validate_timestamp(\n        arrow.get(connector_scope.fetch_timestamp() / 1000), offset)\n\n    # Get alerts\n    connector_scope.LOGGER.info(\"Trying to fetch alerts.\")\n    alerts = alienvault_connector.get_alerts(last_run, max_alert_per_cycle)\n\n    connector_scope.LOGGER.info(\n        \"Successfully found {} alerts.\".format(len(alerts)))\n\n    result_params[\"Fetching Alerts\"] = \"Successful\"\n\n    # Construct CaseInfos from alerts\n    connector_scope.LOGGER.info(\"Testing CaseInfo construction.\")\n\n    cases = []\n    for alert in alerts:\n        try:\n            connector_scope.LOGGER.info(\n                \"Processing alert {}\".format(unicode(alert['Id']).encode(\"utf-8\")))\n\n            case = alienvault_connector.create_case_info(alert, max_events_per_alert)\n            cases.append(case)\n\n        except Exception as e:\n            # Failed to build CaseInfo for alert\n            connector_scope.LOGGER.error(\n                \"Failed to create CaseInfo for alert {}\".format(\n                    unicode(alert['Id']).encode(\"utf-8\"),\n                )\n            )\n            connector_scope.LOGGER.error(\n                \"Error Message: {}\".format(str(e)))\n\n            connector_scope.LOGGER._log.exception(e)\n\n            result_value = False\n\n    if len(cases) != len(alerts):\n        result_value = False\n        connector_scope.LOGGER.error(\n            \"Failed to create cases for some alerts. Check logs for details.\")\n\n    else:\n        result_params[\"Building Case Info\"] = \"Successful\"\n        connector_scope.LOGGER.info(\n            \"Successfully constructed CaseInfo for all alerts.\")\n\n    connector_scope.LOGGER.info(\"Test completed.\")\n\n    # Return data\n    connector_scope.return_test_result(result_value, result_params)\n\n\ndef main():\n    \"\"\"\n    Main execution - AlienVault Connector\n    \"\"\"\n    connector_scope = SiemplifyConnectorMock(\n        {\n            'Api Root': 'https://demo.alienvault.com',\n            'Username': 'guest',\n            'Password': 'alienvault',\n            'Max Days Backwards': '1',\n            'Max Events Per Alert': '3',\n            'Max Alerts Per Cycle': '10'\n        },\n        connector_name=\"AlienVaultTest\"\n    )\n    connector_scope = SiemplifyConnectorExecution()\n    connector_scope.script_name = 'AlienVault Connector'\n    output_variables = {}\n    log_items = []\n\n    connector_scope.LOGGER.info(\"========== Starting Connector ==========.\")\n\n    try:\n        connector_scope.LOGGER.info(\"Connecting to AlienVault\")\n        api_root = connector_scope.parameters['Api Root']\n        username = connector_scope.parameters['Username']\n        password = connector_scope.parameters['Password']\n        max_events_per_alert = int(connector_scope.parameters['Max Events Per Alert'])\n        max_alert_per_cycle = int(connector_scope.parameters['Max Alerts Per Cycle'])\n        offset = int(connector_scope.parameters['Max Days Backwards'])\n\n        alienvault_manager = AlienVaultManager(api_root, username, password)\n        alienvault_connector = AlienVaultConnector(connector_scope,\n                                                   alienvault_manager)\n\n        # Todo: Validate timezone\n        last_run = alienvault_connector.validate_timestamp(\n            arrow.get(connector_scope.fetch_timestamp()), offset)\n\n        # Get alerts from AlienVault\n        connector_scope.LOGGER.info(\"Collecting alerts from AlienVault.\")\n        alerts = alienvault_connector.get_alerts(last_run, max_alert_per_cycle)\n\n        # Construct CaseInfo from alerts\n        cases = []\n\n        for alert in alerts:\n            try:\n                connector_scope.LOGGER.info(\n                    \"Processing alert {}\".format(\n                        unicode(alert['Id']).encode(\"utf-8\")))\n\n                case = alienvault_connector.create_case_info(alert, max_events_per_alert)\n                cases.append(case)\n\n            except Exception as e:\n                # Failed to build CaseInfo for alert\n                connector_scope.LOGGER.error(\n                    \"Failed to create CaseInfo for alert {}: {}\".format(alert['Id'], str(e))\n                )\n                connector_scope.LOGGER.error(\n                    \"Error Message: {}\".format(str(e)))\n        if alerts:\n            try:\n                # Save last index's timestamp\n                alerts = sorted(alerts, key=lambda alert: alienvault_connector.parse_date(alert.get('Date', 0)))\n                with open(os.path.join(connector_scope.run_folder, TIMESTAMP_FILE), \"w\") as timestamp_file:\n                    timestamp_file.write(unicode(alienvault_connector.parse_date(alerts[-1]['Date'])).encode(\"utf-8\"))\n                    connector_scope.LOGGER.info(\"Next timestamp: {}\".format(unicode(arrow.get(alienvault_connector.parse_date(alerts[-1]['Date']))).encode(\"utf-8\")))\n            except Exception as e:\n                connector_scope.LOGGER.error(\"Unable to write timestamp to file: {}\".format(str(e)))\n                connector_scope.LOGGER._log.exception(e)\n\n        connector_scope.LOGGER.info(\n            \"Completed. Found {} cases.\".format(len(cases)))\n\n        # Return data\n        connector_scope.return_package(cases, output_variables, log_items)\n\n    except Exception as e:\n        connector_scope.LOGGER.error(str(e))\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2 or sys.argv[1] == 'True':\n        print \"Main execution started\"\n        main()\n    else:\n        print \"Test execution started\"\n        test()", 
    "SimulationUseCases": {
        "CasesForUseCase": [], 
        "UseCaseName": null
    }, 
    "Version": 1
}