{
    "CreationTimeUnixTimeInMs": 1538573780020, 
    "Creator": "Admin", 
    "Description": "RSA Netwitness static query connector.", 
    "Id": -1, 
    "Integration": "RSANetWitness", 
    "IsConnectorRulesSupported": false, 
    "IsCustom": false, 
    "IsEnabled": true, 
    "MappingRules": [], 
    "ModificationTimeUnixTimeInMs": 1538573780020, 
    "Name": "RSA NetWitness Query Connector", 
    "Parameters": [
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1538573780020, 
            "DefaultValue": "device_product", 
            "Description": "The field name used to determine the device product", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1538573780020, 
            "Name": "DeviceProductField", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1538573780020, 
            "DefaultValue": "name", 
            "Description": "The field name used to determine the event name (sub-type)", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1538573780020, 
            "Name": "EventClassId", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1538573780020, 
            "DefaultValue": "60", 
            "Description": "The timeout limit (in seconds) for the python process running current script", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1538573780020, 
            "Name": "PythonProcessTimeout", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1538573780020, 
            "DefaultValue": "http://x.x.x.x:50105/", 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1538573780020, 
            "Name": "Concentrator URI", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1538573780020, 
            "DefaultValue": "http://x.x.x.x:50102/", 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1538573780020, 
            "Name": "Decoder URI", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1538573780020, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1538573780020, 
            "Name": "Username", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1538573780020, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1538573780020, 
            "Name": "Password", 
            "Type": 3
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1538573780020, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1538573780020, 
            "Name": "Query", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1538573780020, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1538573780020, 
            "Name": "Rule Generator Field", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1538573780020, 
            "DefaultValue": "10", 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1538573780020, 
            "Name": "Alert Count Limit", 
            "Type": 1
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1538573780020, 
            "DefaultValue": "1", 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1538573780020, 
            "Name": "Max Days Backwards", 
            "Type": 1
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1538573780020, 
            "DefaultValue": "time", 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1538573780020, 
            "Name": "Event Time Field", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1539782034720, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1539782034720, 
            "Name": "Verify SSL", 
            "Type": 0
        }, 
        {
            "CreationTimeUnixTimeInMs": 1574099687000, 
            "Name": "Proxy Server Address", 
            "ModificationTimeUnixTimeInMs": 1574099687000, 
            "Type": 2, 
            "DefaultValue": null, 
            "Description": "The address of the proxy server to use.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }, 
        {
            "CreationTimeUnixTimeInMs": 1574099687000, 
            "Name": "Proxy Username", 
            "ModificationTimeUnixTimeInMs": 1574099687000, 
            "Type": 2, 
            "DefaultValue": null, 
            "Description": "The proxy username to authenticate with.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }, 
        {
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Proxy Password", 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Type": 3, 
            "DefaultValue": null, 
            "Description": "The proxy password to authenticate with.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }
    ], 
    "ProductToVisualFamilyRecords": [], 
    "Rules": [], 
    "Script": "# ==============================================================================\n# title           :RSA Incidents Connector.py\n# description     :This Module contain RSA Connector logic.\n# author          :victor@siemplify.co\n# date            :06-08-18\n# python_version  :2.7\n# libraries       : -\n# requirements    :\n# product_version : 1.0\n# ==============================================================================\n\n# =====================================\n#              IMPORTS                #\n# =====================================\nfrom SiemplifyConnectors import SiemplifyConnectorExecution\nfrom SiemplifyConnectorsDataModel import CaseInfo\nfrom SiemplifyUtils import convert_unixtime_to_datetime, convert_string_to_unix_time\nfrom RSAManager import RSA\nimport arrow\nimport uuid\nimport sys\n\n# =====================================\n#             CONSTANTS               #\n# =====================================\nDEFAULT_TIME_FIELD = 'time'\nDEFAULT_TIME_FORMAT = '%Y-%b-%d %H:%M:%S'\nDEFAULT_MAX_DAYS_BACKWARDS = 1\nDEFAULT_MAX_ALERTS_COUNT_LIMIT = 10\nQUERY_TIME_POSTFIX = ' && {0}>{1} && {0}<{2}'  # {0} - Time Field ,{1} - Event Time, {2} - Current Time\nDEFAULT_PRODUCT = 'RSA NetWitness'\n\nEVENT_TIME_FILED_MILLISECONDS = 'event_time_unixtime_milliseconds'\n\n# =====================================\n#              CLASSES                #\n# =====================================\nclass RSAIncidentsConnectorException(Exception):\n    \"\"\"\n    RSA Incidents Connector Exception\n    \"\"\"\n    pass\n\n\nclass RSAQueryConnector(object):\n    \"\"\"\n    RSA Incidents Connector\n    \"\"\"\n    @staticmethod\n    def validate_timestamp(unixtime_timestamp, max_days_backwards=1):\n        \"\"\"\n        Adjust timestamp to the max days backwards value.\n        :param unixtime_timestamp: {long} unix time timestamp.\n        :param max_days_backwards: {int} days backwards to check timestamp.\n        :return: {long} unixtime timestamp\n        \"\"\"\n        # Calculate- Days backwards to milliseconds.\n        offset_unixtime_milliseconds = arrow.now().shift(days=-max_days_backwards).timestamp * 1000\n\n        # Calculate max time with offset.\n        if unixtime_timestamp < offset_unixtime_milliseconds:\n            return offset_unixtime_milliseconds\n        return unixtime_timestamp\n\n    @staticmethod\n    def form_query(default_query, event_time_field, last_event_time=0):\n        \"\"\"\n        Form final connector query that will be sent to RSA Netwitness.\n        :param default_query: {string} query recieved from the user.\n        :param time_format: time format as the time string at the query {string}\n        :param event_time_field: {string} the name of the field of the event time.\n        :param last_event_time: {long} unixtime timestamp\n        :return: {string} final query\n        \"\"\"\n        # Get current time in unixtime.\n        now_time_string = arrow.Arrow.utcnow().timestamp\n        last_event_time_string = arrow.get(convert_unixtime_to_datetime(last_event_time)).timestamp\n        # Add to the query the time limits.\n        return \"{0}{1}\".format(default_query, QUERY_TIME_POSTFIX.format(event_time_field, last_event_time_string,\n                                                                        now_time_string))\n\n    @staticmethod\n    def create_case(event_metadata, device_product_field, rule_generator_field,  event_time_field, environment, query):\n        \"\"\"\n        Create a case objest.\n        :param event_metadata: {dict} raw data of the event.\n        :param device_product_field: {string} the name of the field which contains the device product\n        :param rule_generator_field: {string} the name of the field which contain the rule generator value\n        :param event_time_field: {string} the name of the field which contain the time value\n        :param environment: {string} the value of the environment name\n        :param query: {string} the full query that was sent to Netwitness\n        :return:\n        \"\"\"\n        case_info = CaseInfo()\n        case_info.start_time = long(event_metadata.get(event_time_field, 1))\n        # The time is delivered in second but needed in milliseconds.\n        if not case_info.start_time == 1:\n            case_info.start_time = case_info.start_time * 1000\n        case_info.end_time = case_info.start_time\n        case_info.rule_generator = event_metadata.get(rule_generator_field, 'No rule generator field found.')\n        case_info.device_product = event_metadata.get(device_product_field, DEFAULT_PRODUCT)\n        case_info.device_vendor = case_info.device_product\n        case_info.environment = environment\n\n        case_info.name = event_metadata.get(\"sessionid\", 'Alert has no name.')\n        # If no Session ID, replace with timestamp + uuid because timestamp can be not unique in some cases.\n        case_info.ticket_id = event_metadata.get(\"sessionid\", \"{0}_{1}\".format(case_info.start_time,\n                                                                               unicode(uuid.uuid4())))\n        case_info.display_id = case_info.identifier = case_info.ticket_id\n\n        # Add milliseconds time field to the event(For Mapping).\n        event_metadata[EVENT_TIME_FILED_MILLISECONDS] = case_info.start_time\n\n        case_info.events = [event_metadata]\n\n        # Add additional data to case.\n        case_info.extensions.update({\"session_id\": event_metadata.get(\"sessionid\"),\n                                     \"query\": query})\n        return case_info\n\n\ndef main_handler(test_handler=False):\n    \"\"\"\n    :param test_handler: run test flow of real flow (timestamp updating is the differencee)\n    :return: -\n    \"\"\"\n    connector_scope = SiemplifyConnectorExecution()\n    output_variables = {}\n    log_items = []\n    cases = []\n    is_overflowed = False\n\n    try:\n\n        if test_handler:\n            connector_scope.LOGGER.info(\" ------------ Starting RSA  Connector test. ------------ \")\n        else:\n            connector_scope.LOGGER.info(\" ------------ Starting Connector. ------------ \")\n\n        concentrator_uri = connector_scope.parameters.get('Concentrator URI')\n        decoder_uri = connector_scope.parameters.get('Decoder URI')\n        username = connector_scope.parameters.get('Username')\n        password = connector_scope.parameters.get('Password')\n        query = connector_scope.parameters.get('Query')\n        device_product_field = connector_scope.parameters.get('DeviceProductField')\n        rule_generator_field = connector_scope.parameters.get('Rule Generator Field')\n        alert_count_limit = int(connector_scope.parameters.get('Alert Count Limit', DEFAULT_MAX_ALERTS_COUNT_LIMIT))\n        max_days_backwards = int(connector_scope.parameters.get('Max Days Backwards', DEFAULT_MAX_DAYS_BACKWARDS))\n        event_time_field = connector_scope.parameters.get('Event Time Field', DEFAULT_TIME_FIELD)\n\n        rsa_manager = RSA(concentrator_uri=concentrator_uri,\n                          decoder_uri=decoder_uri,\n                          username=username,\n                          password=password)\n        rsa_connector = RSAQueryConnector()\n\n        # Fetch last event time from the timestamp file.\n        last_event_time = rsa_connector.validate_timestamp(connector_scope.fetch_timestamp(), max_days_backwards)\n        final_query = rsa_connector.form_query(query, event_time_field, last_event_time)\n\n        session_ids = rsa_manager.get_session_ids_for_query(final_query)\n        connector_scope.LOGGER.info(\"Found {0} session IDs.\".format(len(session_ids)))\n        limited_session_ids = session_ids[:1] if test_handler else session_ids[:alert_count_limit]\n\n        for session_id in limited_session_ids:\n            connector_scope.LOGGER.info(\"Running on session with ID: {0}.\".format(session_id))\n            try:\n                event_metadata = rsa_manager.get_metadata_from_session_id(session_id)\n                connector_scope.LOGGER.info('Got event metadata for session ID: {0}'.format(session_id))\n            except Exception as err:\n                error_massage = 'Error occurred fetching metadata for session ID: {0}, Error: {1}'.format(\n                    session_id,\n                    err.message\n                )\n                connector_scope.LOGGER.error(error_massage)\n                connector_scope.LOGGER.exception(err)\n                continue\n\n            # Create case package.\n            try:\n                case = rsa_connector.create_case(event_metadata, device_product_field, rule_generator_field,\n                                                 event_time_field, connector_scope.context.connector_info.environment,\n                                                 final_query)\n                connector_scope.LOGGER.info(\"Case with display id: {0}, created successfully.\".format(case.display_id))\n            except Exception as err:\n                error_massage = 'Error creating case package.'\n                connector_scope.LOGGER.error(error_massage)\n                connector_scope.LOGGER.exception(err)\n                continue\n\n            # Check if overflowed.\n            try:\n                is_overflowed = connector_scope.is_overflowed_alert(\n                    environment=case.environment,\n                    alert_identifier=str(case.ticket_id),\n                    alert_name=str(case.rule_generator),\n                    product=str(case.device_product))\n\n            except Exception as err:\n                connector_scope.LOGGER.err(\n                    'Error validation connector overflow, ERROR: {0}'.format(unicode(err)))\n                connector_scope.LOGGER.exeption(err)\n\n            if is_overflowed:\n                connector_scope.LOGGER.info(\n                    \"{alert_name}-{alert_identifier}-{environment}-{product} found as overflow alert. Skipping.\"\n                        .format(alert_name=str(case.rule_generator),\n                                alert_identifier=str(case.ticket_id),\n                                environment=str(case.environment),\n                                product=str(case.device_product)))\n            else:\n                cases.append(case)\n                connector_scope.LOGGER.info('Case with display id \"{0}\" was created.'.format(case.display_id))\n\n        if test_handler:\n            connector_scope.LOGGER.info(\" ------------ Finish RSA Connector Test ------------ \")\n            connector_scope.return_test_result(True, {})\n            return\n\n        # Update last run time: Take the start time of the last case at the cases list.\n        if cases:\n            connector_scope.save_timestamp(new_timestamp=cases[-1:][0].start_time)\n\n        connector_scope.LOGGER.info(\" ------------ Connector Finished Iteration ------------ \")\n        connector_scope.return_package(cases, output_variables, log_items)\n\n    except Exception as err:\n        error_message = 'Got exception on main handler. Error: {0}'.format(err)\n        if test_handler:\n            connector_scope.return_test_result(False, {})\n            raise RSAIncidentsConnectorException(error_message)\n        connector_scope.LOGGER.error(error_message)\n        connector_scope.LOGGER.exception(err)\n\n\ndef test():\n    \"\"\"\n    Test execution -\n    \"\"\"\n    main_handler(test_handler=True)\n\n\ndef main():\n    \"\"\"\n    Main execution -\n    \"\"\"\n    main_handler()\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2 or sys.argv[1] == 'True':\n        print \"Main execution started\"\n        main()\n    else:\n        print \"Test execution started\"\n        test()\n\n", 
    "SimulationUseCases": {
        "CasesForUseCase": [], 
        "UseCaseName": null
    }, 
    "Version": 1
}