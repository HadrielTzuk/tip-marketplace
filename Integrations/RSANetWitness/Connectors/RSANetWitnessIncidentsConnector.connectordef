{
    "CreationTimeUnixTimeInMs": 1539782034720, 
    "Creator": "Admin", 
    "Description": "RSA NetWitness Incidents Connector", 
    "Id": -1, 
    "Integration": "RSANetWitness", 
    "IsConnectorRulesSupported": false, 
    "IsCustom": false, 
    "IsEnabled": true, 
    "MappingRules": [], 
    "ModificationTimeUnixTimeInMs": 1539782034720, 
    "Name": "RSA NetWitness Incidents Connector", 
    "Parameters": [
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1539782034720, 
            "DefaultValue": "device_product", 
            "Description": "The field name used to determine the device product", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1539782034720, 
            "Name": "DeviceProductField", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1539782034720, 
            "DefaultValue": "name", 
            "Description": "The field name used to determine the event name (sub-type)", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1539782034720, 
            "Name": "EventClassId", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1539782034720, 
            "DefaultValue": "60", 
            "Description": "The timeout limit (in seconds) for the python process running current script", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1539782034720, 
            "Name": "PythonProcessTimeout", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1539782034720, 
            "DefaultValue": "https://x.x.x.x/", 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1539782034720, 
            "Name": "UI URI", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1539782034720, 
            "DefaultValue": "http://x.x.x.x:50105/", 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1539782034720, 
            "Name": "Concentrator URI", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1539782034720, 
            "DefaultValue": "https://x.x.x.x:50102/", 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1539782034720, 
            "Name": "Decoder URI", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1539782034720, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1539782034720, 
            "Name": "Username", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1539782034720, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1539782034720, 
            "Name": "Password", 
            "Type": 3
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1539782034720, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1539782034720, 
            "Name": "Rule Generator Field", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1539782034720, 
            "DefaultValue": "time", 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1539782034720, 
            "Name": "Event Time Field", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1539782034720, 
            "DefaultValue": "1", 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1539782034720, 
            "Name": "Max Days Backwards", 
            "Type": 1
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1539782034720, 
            "DefaultValue": "10", 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1539782034720, 
            "Name": "Incidents Count Limit", 
            "Type": 1
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1539782034720, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1539782034720, 
            "Name": "Verify SSL", 
            "Type": 0
        }, 
        {
            "CreationTimeUnixTimeInMs": 1574099687000, 
            "Name": "Proxy Server Address", 
            "ModificationTimeUnixTimeInMs": 1574099687000, 
            "Type": 2, 
            "DefaultValue": null, 
            "Description": "The address of the proxy server to use.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }, 
        {
            "CreationTimeUnixTimeInMs": 1574099687000, 
            "Name": "Proxy Username", 
            "ModificationTimeUnixTimeInMs": 1574099687000, 
            "Type": 2, 
            "DefaultValue": null, 
            "Description": "The proxy username to authenticate with.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }, 
        {
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Proxy Password", 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Type": 3, 
            "DefaultValue": null, 
            "Description": "The proxy password to authenticate with.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }
    ], 
    "ProductToVisualFamilyRecords": [], 
    "Rules": [], 
    "Script": "# ==============================================================================\n# title           :RSA Incidents Connector.py\n# description     :This Module contain RSA Connector logic.\n# author          :victor@siemplify.co\n# date            :06-08-18\n# python_version  :2.7\n# libraries       : -\n# requirements    :\n# product_version : 1.0\n# ==============================================================================\n\n# =====================================\n#              IMPORTS                #\n# =====================================\nfrom SiemplifyConnectors import SiemplifyConnectorExecution\nfrom SiemplifyConnectorsDataModel import CaseInfo\nfrom RSAManager import RSA\nfrom SiemplifyUtils import dict_to_flat, convert_unixtime_to_datetime, convert_string_to_unix_time\nimport datetime\nimport arrow\nimport uuid\nimport sys\n\n# =====================================\n#             CONSTANTS               #\n# =====================================\n\nDEFAULT_TIME_FIELD = 'time'\nDEFAULT_PRODUCT = 'RSA NetWitness'\nTIME_UNIXTIME_FIELD = 'time_unixtime'\nDEFAULT_ALERT_NAME_FIELD = 'title'\nDEFAULT_MAX_DAYS_BACKWARDS = 1\nDEFAULT_INCIDENTS_COUNT = 10\n\n\n# =====================================\n#              CLASSES                #\n# =====================================\nclass RSAIncidentsConnectorException(Exception):\n    \"\"\"\n    RSA Incidents Connector Exception\n    \"\"\"\n    pass\n\n\nclass RSAIncidentsConnector(object):\n    \"\"\"\n    RSA Incidents Connector\n    \"\"\"\n\n    @staticmethod\n    def validate_timestamp(unixtime_timestamp, max_days_backwards=1):\n        \"\"\"\n        Adjust timestamp to the max days backwards value.\n        :param unixtime_timestamp: {long} unix time timestamp.\n        :param max_days_backwards: {int} days backwards to check timestamp.\n        :return: {long} unixtime timestamp\n        \"\"\"\n        # Calculate max time with offset.\n        offset_unixtime_milliseconds = arrow.utcnow().shift(days=-max_days_backwards).timestamp * 1000\n\n        if unixtime_timestamp <= offset_unixtime_milliseconds:\n            return offset_unixtime_milliseconds\n        return unixtime_timestamp\n\n    @staticmethod\n    def create_case(alert, alert_events, device_product_field, rule_generator_field, event_time_field,\n                    environment):\n        \"\"\"\n        Create case object.\n        :param alert: {dict} RSA NetWitness alert object.\n        :param alert_events: {list} List of alert events objects.\n        :param device_product_field: {string} The field at the event that holds the device product value.\n        :param rule_generator_field: {string} The field at the event that holds the rule generator value.\n        :param event_time_field: {string} The field at the event that holds the event time value.\n        :param environment: {string} The field at the event that holds the environment value.\n        :return: {CaseInfo} Case object.\n        \"\"\"\n\n        # Sort Events.\n        alert_events.sort(key=lambda x: x.get(event_time_field))\n\n        # Add unixtime milliseconds field to each event for mapping reasons.\n        for event in alert_events:\n            event[TIME_UNIXTIME_FIELD] = event.get(event_time_field) * 1000 if event.get(event_time_field) else 1\n        case_info = CaseInfo()\n        if alert_events:\n            case_info.start_time = alert_events[0].get(event_time_field) * 1000 \\\n                if alert_events[0].get(event_time_field) else 1\n            case_info.end_time = alert_events[-1:][0].get(event_time_field) * 1000 \\\n                if alert_events[-1:][0].get(event_time_field) else 1\n            case_info.rule_generator = alert_events[0].get(rule_generator_field, 'No rule generator field found.')\n            case_info.device_product = alert_events[0].get(device_product_field, DEFAULT_PRODUCT)\n\n        case_info.device_vendor = case_info.device_product\n        case_info.environment = environment\n\n        case_info.name = alert.get(DEFAULT_ALERT_NAME_FIELD, 'Alert has no name.')\n        # If no Session ID, replace with timestamp + uuid because timestamp can be not unique in some cases.\n        case_info.ticket_id = alert.get(\"id\", \"{0}_{1}\".format(case_info.start_time,\n                                                                               unicode(uuid.uuid4())))\n        case_info.display_id = case_info.identifier = case_info.ticket_id\n\n        case_info.events = map(dict_to_flat, alert_events)\n\n        return case_info\n\n\ndef main_handler(test_handler=False):\n    \"\"\"\n    :param test_handler: run test flow of real flow (timestamp updating is the differencee)\n    :return:\n    \"\"\"\n    connector_scope = SiemplifyConnectorExecution()\n    output_variables = {}\n    log_items = []\n    cases = []\n    is_overflowed = False\n\n    try:\n\n        if test_handler:\n            connector_scope.LOGGER.info(\" ------------ Starting RSA  Connector test. ------------ \")\n        else:\n            connector_scope.LOGGER.info(\" ------------ Starting Connector. ------------ \")\n        ui_uri = connector_scope.parameters.get('UI URI')\n        concentrator_uri = connector_scope.parameters.get('Concentrator URI')\n        decoder_uri = connector_scope.parameters.get('Decoder URI')\n        username = connector_scope.parameters.get('Username')\n        password = connector_scope.parameters.get('Password')\n        device_product_field = connector_scope.parameters.get('DeviceProductField')\n        rule_generator_field = connector_scope.parameters.get('Rule Generator Field')\n        incidents_count_limit = int(connector_scope.parameters.get('Incidents Count Limit', DEFAULT_INCIDENTS_COUNT))\n        max_days_backwards = int(connector_scope.parameters.get('Max Days Backwards', DEFAULT_MAX_DAYS_BACKWARDS))\n        event_time_field = connector_scope.parameters.get('Event Time Field', DEFAULT_TIME_FIELD)\n        use_ssl = connector_scope.parameters.get('Use SSL', 'false').lower() == 'true'\n\n        rsa_manager = RSA(ui_uri=ui_uri,\n                          concentrator_uri=concentrator_uri,\n                          decoder_uri=decoder_uri,\n                          username=username,\n                          password=password,\n                          use_ssl=use_ssl)\n\n        rsa_connector = RSAIncidentsConnector()\n\n        alerts = []\n\n        # Fetch last event time from the timestamp file.\n        last_event_time = rsa_connector.validate_timestamp(connector_scope.fetch_timestamp(), max_days_backwards)\n\n        incidents = rsa_manager.get_incident_in_time_range(from_time=convert_unixtime_to_datetime(last_event_time))\n        connector_scope.LOGGER.info('Fetched {0} incidents since {1}, incidents IDs: {2}'.format(\n            len(incidents),\n            last_event_time,\n            \", \".join([incident.get('id') for incident in incidents])\n        ))\n\n        # Incidents are received sorted.\n        limited_incidents = incidents[-1:] if test_handler else incidents[-incidents_count_limit:]\n\n        connector_scope.LOGGER.info('After slicing left incidents with IDs: {0}'.format(\n            \", \".join([incident.get('id') for incident in limited_incidents])\n        ))\n\n        for incident in limited_incidents:\n            try:\n                alerts.extend(rsa_manager.fetch_alerts_for_incident_by_id(incident.get('id')))\n            except Exception as err:\n                error_message = \"Error occurred fetching alerts for incident with ID '{0}', Error: {1}\".format(\n                    incident.get('id'),\n                    err.message\n                )\n                connector_scope.LOGGER.error(error_message)\n                connector_scope.LOGGER.exception(err)\n                if test_handler:\n                    raise RSAIncidentsConnectorException(error_message)\n\n        for alert in alerts:\n            events_session_ids = [event.get('eventSourceId') for event in alert.get('events', [])\n                                  if event.get('eventSourceId')]\n            alert_events = []\n            for session_id in events_session_ids:\n                try:\n                    connector_scope.LOGGER.info('Fetching event for session ID \"{0}\"'.format(session_id))\n                    alert_events.append(rsa_manager.get_metadata_from_session_id(session_id))\n                except Exception as err:\n                    error_message = \"Error occurred fetching event for session ID '{0}', Error: {1}\".format(\n                        session_id,\n                        err.message\n                    )\n                    connector_scope.LOGGER.error(error_message)\n                    connector_scope.LOGGER.exception(err)\n                    if test_handler:\n                        raise RSAIncidentsConnectorException(error_message)\n            try:\n                case = rsa_connector.create_case(alert, alert_events, device_product_field, rule_generator_field, event_time_field, connector_scope.context.connector_info.environment)\n\n                # Check if overflowed.\n                try:\n                    is_overflowed = connector_scope.is_overflowed_alert(\n                        environment=case.environment,\n                        alert_identifier=str(case.ticket_id),\n                        alert_name=str(case.rule_generator),\n                        product=str(case.device_product))\n\n                except Exception as err:\n                    connector_scope.LOGGER.err(\n                        'Error validation connector overflow, ERROR: {0}'.format(unicode(err)))\n                    connector_scope.LOGGER.exeption(err)\n\n                if is_overflowed:\n                    connector_scope.LOGGER.info(\n                        \"{alert_name}-{alert_identifier}-{environment}-{product} found as overflow alert. Skipping.\"\n                            .format(alert_name=str(case.rule_generator),\n                                    alert_identifier=str(case.ticket_id),\n                                    environment=str(case.environment),\n                                    product=str(case.device_product)))\n                else:\n                    cases.append(case)\n                    connector_scope.LOGGER.info('Case with display id \"{0}\" was created.'.format(case.display_id))\n\n            except Exception as err:\n                error_message = \"Error occurred creating case for alert with ID '{0}' amd title '{1}', Error: {2}\".format(\n                    alert.get('id'),\n                    alert.get('title'),\n                    err.message\n                )\n                connector_scope.LOGGER.error(error_message)\n                connector_scope.LOGGER.exception(err)\n                if test_handler:\n                    raise RSAIncidentsConnectorException(error_message)\n\n        if not test_handler:\n            if limited_incidents:\n                # Sort incidents by time.\n                limited_incidents.sort(key=lambda x: convert_string_to_unix_time(x.get('created')))\n                # Take the last incident and save it's creation time.\n                # Add additional second to the final time in order to not fetch the incident that was fetched earlier.\n                connector_scope.save_timestamp(new_timestamp=convert_string_to_unix_time(\n                    limited_incidents[-1:][0].get('created')) + 1000)\n\n        connector_scope.LOGGER.info(\" ------------ Connector Finished Iteration ------------ \")\n        if test_handler:\n            connector_scope.return_test_result(True, {})\n        else:\n            connector_scope.return_package(cases, output_variables, log_items)\n\n    except Exception as err:\n        error_message = 'Got exception on main handler. Error: {0}'.format(err)\n        if test_handler:\n            raise RSAIncidentsConnectorException(error_message)\n        connector_scope.LOGGER.error(error_message)\n        connector_scope.LOGGER.exception(err)\n\n\ndef test():\n    \"\"\"\n    Test execution -\n    \"\"\"\n    main_handler(test_handler=True)\n\n\ndef main():\n    \"\"\"\n    Main execution -\n    \"\"\"\n    main_handler()\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2 or sys.argv[1] == 'True':\n        print \"Main execution started\"\n        main()\n    else:\n        print \"Test execution started\"\n        test()\n\n", 
    "SimulationUseCases": {
        "CasesForUseCase": [], 
        "UseCaseName": null
    }, 
    "Version": 1
}