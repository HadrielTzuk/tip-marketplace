{
    "CreationTimeUnixTimeInMs": 1526544275967, 
    "Creator": "admin", 
    "Description": "", 
    "Id": -1, 
    "Integration": "CBResponse", 
    "IsConnectorRulesSupported": false, 
    "IsCustom": false,
    "IsEnabled": true, 
    "MappingRules": [], 
    "ModificationTimeUnixTimeInMs": 1526544275967, 
    "Name": "Carbon Black Response Connector", 
    "Parameters": [
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526544275967, 
            "DefaultValue": "device_product", 
            "Description": "The field name used to determine the device product", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1526544275967, 
            "Name": "DeviceProductField", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526544275967, 
            "DefaultValue": "name", 
            "Description": "The field name used to determine the event name (sub-type)", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1526544275967, 
            "Name": "EventClassId", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526544275967, 
            "DefaultValue": "60", 
            "Description": "The timeout limit (in seconds) for the python process running current script", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1526544275967, 
            "Name": "PythonProcessTimeout", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526544275967, 
            "DefaultValue": null, 
            "Description": "https://x.x.x.x", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1526544275967, 
            "Name": "Api Root", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526544275967, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1526544275967, 
            "Name": "Api Key", 
            "Type": 3
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1526544275967,
            "DefaultValue": "6.3",
            "Description": "CB server version, default 6.3 will be used",
            "Id": -1,
            "IsMandatory": true,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1526544275967,
            "Name": "Version",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526544275967, 
            "DefaultValue": "20", 
            "Description": "Limit the number of alerts in every cycle. e.g. 20.", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1526544275967, 
            "Name": "Alerts Count Limit", 
            "Type": 1
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526544275967, 
            "DefaultValue": "3", 
            "Description": "This field is used in the connector first running cycle and determine the connector start time. e.g. 3", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1526544275967, 
            "Name": "Max Days Backwards", 
            "Type": 1
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526544275967, 
            "DefaultValue": null, 
            "Description": "The name of the environment's field.", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1526544275967, 
            "Name": "Environment Field Name", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526544275967, 
            "DefaultValue": null, 
            "Description": "Can be whitelist or blacklist.", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1526544275967, 
            "Name": "List Type", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526544275967, 
            "DefaultValue": null, 
            "Description": "Can be 'exact', 'start with', 'ends with' or 'contains'.", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1526544275967, 
            "Name": "List Operator", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1526544275967, 
            "DefaultValue": null, 
            "Description": "List of fields, comma separated.", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1526544275967, 
            "Name": "List Fields", 
            "Type": 2
        }, 
        {
            "CreationTimeUnixTimeInMs": 1574099687000, 
            "Name": "Proxy Server Address", 
            "ModificationTimeUnixTimeInMs": 1574099687000, 
            "Type": 2, 
            "DefaultValue": null, 
            "Description": "The address of the proxy server to use.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }, 
        {
            "CreationTimeUnixTimeInMs": 1574099687000, 
            "Name": "Proxy Username", 
            "ModificationTimeUnixTimeInMs": 1574099687000, 
            "Type": 2, 
            "DefaultValue": null, 
            "Description": "The proxy username to authenticate with.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }, 
        {
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Proxy Password", 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Type": 3, 
            "DefaultValue": null, 
            "Description": "The proxy password to authenticate with.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }
    ], 
    "ProductToVisualFamilyRecords": [], 
    "Rules": [], 
    "Script": "# ============================================================================#\n# title           :CBResponseConnector.py\n# description     :This Module contain all CBResponse connector functionality\n# author          :avital@siemplify.co\n# date            :17-05-2018\n# python_version  :2.7\n# ============================================================================#\n\n# ============================= IMPORTS ===================================== #\n\nimport sys\nimport datetime\nimport copy\nimport arrow\nfrom SiemplifyUtils import dict_to_flat, utc_now, convert_datetime_to_unix_time\nfrom SiemplifyConnectors import CaseInfo, SiemplifyConnectorExecution\nfrom CarbonBlackResponseManager import CBResponseManager\n\n# ============================== CONSTS ===================================== #\nDEFAULT_PRODUCT = DEFAULT_VENDOR = \"Carbon Black Response\"\nALERTS_LIMIT = 20\nTIMEZONE = \"UTC\"\nTIME_FORMAT = \"%Y-%m-%dT%H:%M:%S\"\nQUERY = \"created_time: [{} TO *] and status:Unresolved\"\n# ============================= CLASSES ===================================== #\n\n\nclass CBResponseConnectorException(Exception):\n    \"\"\"\n    CBResponse Exception\n    \"\"\"\n    pass\n\n\nclass CBResponseConnector(object):\n    \"\"\"\n    CBResponse Connector\n    \"\"\"\n\n    def __init__(self, connector_scope, cbresponse_manager):\n        self.connector_scope = connector_scope\n        self.logger = connector_scope.LOGGER\n        self.cbresponse_manager = cbresponse_manager\n\n    @staticmethod\n    def validate_timestamp(last_run_timestamp, offset):\n        \"\"\"\n        Validate timestamp in range\n        :param last_run_timestamp: {arrow datetime} last run timestamp\n        :param offset: {datetime} last run timestamp\n        :return: {datetime} if first run, return current time minus offset time, else return timestamp from file\n        \"\"\"\n        # Check if first run\n        if last_run_timestamp.shift(days=offset) < arrow.utcnow():\n            return arrow.utcnow().shift(days=-offset)\n        else:\n            return last_run_timestamp\n\n    def get_alerts(self, last_run):\n        \"\"\"\n        Fetch alerts from CBResponse from last run\n        :param last_run: {str} The time to fetch the alerts from (%Y-%m-%dT%H:%M:%S)\n        :return: {list} List of found alerts\n        \"\"\"\n        all_alerts =  self.cbresponse_manager.get_alerts(\n            QUERY.format(last_run)\n        )\n\n        return sorted(all_alerts, key=lambda alert: arrow.get(alert['created_time']))\n\n    # alerts = []\n    # for alert in all_alerts:\n    #     is_overflow = True\n    #\n    #     try:\n    #         is_overflow = self.connector_scope.is_overflowed_alert(\n    #             environment=self.connector_scope.context.connector_info.environment,\n    #             alert_identifier=alert['unique_id'],\n    #             ingestion_time=alert['created_time'],\n    #             alert_name=alert['watchlist_name'])\n    #\n    #     except Exception as e:\n    #         self.logger.error(\n    #             \"Failed to detect overflow for alert {}: {}\".format(\n    #                 alert['unique_id'],\n    #                 alert['watchlist_name']\n    #             )\n    #         )\n    #         self.logger.error(\n    #             \"Error Message: {}\".format(str(e)))\n    #\n    #     if not is_overflow:\n    #         # Generate case info for the alert\n    #         alerts.append(alert)\n    #\n    #     else:\n    #         self.logger.warn(\"Overflowed on alert {}: {}\".format(\n    #                 alert['unique_id'],\n    #                 alert['watchlist_name']\n    #             )\n    #         )\n    #\n    # return alerts\n\n    def create_case_info(self, alert):\n        \"\"\"\n        Create CaseInfo object from CBResponse alert\n        :param alert: {dict} An ES alert\n        :return: {CaseInfo} The newly created case\n        \"\"\"\n        self.logger.info(\n            \"Creating Case for Alert {}\".format(unicode(alert['unique_id']).encode(\"utf-8\")))\n\n        try:\n            # Create the CaseInfo\n            case_info = CaseInfo()\n\n            case_info.name = alert.get('watchlist_name', \"\")\n            case_info.ticket_id = alert['unique_id']\n\n            case_info.rule_generator = alert.get('watchlist_name', \"\")\n            case_info.display_id = alert['unique_id']\n            case_info.device_vendor = DEFAULT_VENDOR\n            case_info.device_product = DEFAULT_PRODUCT\n\n            try:\n                # TODO: Verify timezone.\n                alert_time = arrow.get(alert.get('created_time', 0)).timestamp\n            except Exception as e:\n                self.logger.error(\n                    \"Unable to get alert time: {}\".format(str(e)))\n                self.logger._log.exception(e)\n                alert_time = 0\n\n            case_info.start_time = alert_time\n            case_info.end_time = alert_time\n\n            case_info.environment = self.connector_scope.context.connector_info.environment\n\n        except KeyError as e:\n            raise KeyError(\"Mandatory key is missing: {}\".format(str(e)))\n\n        # Split the alert to events and flatten them\n        try:\n            events = []\n\n            if alert.get('observed_filename'):\n                for observed_file in alert.get('observed_filename', []):\n                    event = copy.deepcopy(alert)\n                    event['observed_filename'] = observed_file\n                    events.append(event)\n\n            else:\n                events = [alert]\n\n            flat_events = map(dict_to_flat, events)\n\n        except Exception as e:\n            self.logger.error(\"Unable to split and flat events: {}\".format(str(e)))\n            self.logger._log.exception(e)\n            flat_events = []\n\n        case_info.events = flat_events\n\n        return case_info\n\n\ndef test():\n    \"\"\"\n    Test execution - CBResponse Connector\n    \"\"\"\n    connector_scope = SiemplifyConnectorExecution()\n    connector_scope.script_name = 'CBResponse Connector'\n    result_params = {}\n    result_value = True\n\n    connector_scope.LOGGER.info(\"========== Starting Connector Test ==========.\")\n\n    connector_scope.LOGGER.info(\"Testing connection to CBResponse\")\n    api_root = connector_scope.parameters['Api Root']\n    api_key = connector_scope.parameters['Api Key']\n    offset = int(connector_scope.parameters['Max Days Backwards'])\n\n    cb_response = CBResponseManager(api_root, api_key)\n\n    connector_scope.LOGGER.info(\"Connection is successful.\")\n\n    cbresponse_connector = CBResponseConnector(connector_scope, cb_response)\n\n    # Todo: Validate timezone\n    last_run = cbresponse_connector.validate_timestamp(\n        arrow.get(connector_scope.fetch_timestamp() / 1000), offset)\n    last_run = last_run.strftime(TIME_FORMAT)\n\n    # Get alerts\n    connector_scope.LOGGER.info(\"Trying to fetch alerts.\")\n    alerts = cbresponse_connector.get_alerts(last_run)\n\n    connector_scope.LOGGER.info(\n        \"Successfully found {} alerts.\".format(len(alerts)))\n\n    # Construct CaseInfos from alerts\n    connector_scope.LOGGER.info(\"Testing CaseInfo construction.\")\n\n    cases = []\n    for alert in alerts:\n        try:\n            connector_scope.LOGGER.info(\n                \"Processing alert {}: \".format(unicode(alert['unique_id']).encode(\"utf-8\"),\n                                               unicode(alert.get('watchlist_name')).encode(\"utf-8\")))\n\n            case = cbresponse_connector.create_case_info(alert)\n            cases.append(case)\n\n        except Exception as e:\n            # Failed to build CaseInfo for alert\n            connector_scope.LOGGER.error(\n                \"Failed to create CaseInfo for alert {}\".format(\n                    unicode(alert['unique_id']).encode(\"utf-8\"),\n                )\n            )\n            connector_scope.LOGGER.error(\n                \"Error Message: {}\".format(str(e)))\n\n            connector_scope.LOGGER._log.exception(e)\n\n            result_value = False\n\n    if len(cases) != len(alerts):\n        result_value = False\n        connector_scope.LOGGER.error(\n            \"Failed to create cases for some alerts. Check logs for details.\")\n\n    else:\n        connector_scope.LOGGER.info(\n            \"Successfully constructed CaseInfo for all alerts.\")\n\n    connector_scope.LOGGER.info(\"Test completed.\")\n\n    # Return data\n    connector_scope.return_test_result(result_value, result_params)\n\n\ndef main():\n    \"\"\"\n    Main execution - CBResponse Connector\n    \"\"\"\n    connector_scope = SiemplifyConnectorExecution()\n    connector_scope.script_name = 'CBResponse Connector'\n    output_variables = {}\n    log_items = []\n\n    connector_scope.LOGGER.info(\"========== Starting Connector ==========.\")\n\n    try:\n        connector_scope.LOGGER.info(\"Connecting to CBResponse\")\n        api_root = connector_scope.parameters['Api Root']\n        api_key = connector_scope.parameters['Api Key']\n        offset = int(connector_scope.parameters['Max Days Backwards'])\n\n        cb_response = CBResponseManager(api_root, api_key)\n        cbresponse_connector = CBResponseConnector(connector_scope,\n                                                cb_response)\n\n        # Todo: Validate timezone\n        last_run = cbresponse_connector.validate_timestamp(\n            arrow.get(connector_scope.fetch_timestamp() / 1000), offset)\n        last_run = last_run.strftime(TIME_FORMAT)\n\n        # Get alerts from CBResponse\n        connector_scope.LOGGER.info(\"Collecting alerts from CBResponse.\")\n        alerts = cbresponse_connector.get_alerts(last_run)\n\n        # Construct CaseInfo from alerts\n        cases = []\n\n        for alert in alerts:\n            try:\n                connector_scope.LOGGER.info(\n                    \"Processing alert {}: \".format(\n                        unicode(alert['unique_id']).encode(\"utf-8\"),\n                        unicode(alert.get('watchlist_name')).encode(\"utf-8\")))\n\n                case = cbresponse_connector.create_case_info(alert)\n                cases.append(case)\n\n            except Exception as e:\n                # Failed to build CaseInfo for alert\n                connector_scope.LOGGER.error(\n                    \"Failed to create CaseInfo for alert {}: {}\".format(alert['unique_id'], str(e))\n                )\n                connector_scope.LOGGER.error(\n                    \"Error Message: {}\".format(str(e)))\n\n        connector_scope.LOGGER.info(\n            \"Completed. Found {} cases.\".format(len(cases)))\n\n        connector_scope.save_timestamp()\n\n        # Return data\n        connector_scope.return_package(cases, output_variables, log_items)\n\n    except Exception as e:\n        connector_scope.LOGGER.error(str(e))\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2 or sys.argv[1] == 'True':\n        print \"Main execution started\"\n        main()\n    else:\n        print \"Test execution started\"\n        test()", 
    "SimulationUseCases": {
        "CasesForUseCase": [], 
        "UseCaseName": null
    }, 
    "Version": 1,
    "DocumentationLink": "https://integrations.siemplify.co/doc/carbon-black-response#connectors"
}