{
    "CreationTimeUnixTimeInMs": 1525167465721, 
    "Creator": "admin", 
    "Description": "", 
    "Id": -1, 
    "Integration": "Email", 
    "IsConnectorRulesSupported": false, 
    "IsCustom": false, 
    "IsEnabled": true, 
    "MappingRules": [], 
    "ModificationTimeUnixTimeInMs": 1525167465721, 
    "Name": "Email Connector", 
    "Parameters": [
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": "device_product", 
            "Description": "The field name used to determine the device product", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "DeviceProductField", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": "event_name", 
            "Description": "The field name used to determine the event name (sub-type)", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "EventClassId", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": "60", 
            "Description": "The timeout limit (in seconds) for the python process running current script", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 0, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "PythonProcessTimeout", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": null, 
            "Description": "Mail address to pull emails from. e.g. user@gmail.com", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Sender's address", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": null, 
            "Description": "e.g. imap.gmail.com", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "IMAP Server Address", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": null, 
            "Description": "Imap port. e.g. 993", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "IMAP Port", 
            "Type": 1
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": null, 
            "Description": "Mail address to pull emails from. e.g. user@gmail.com", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Username", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": null, 
            "Description": "", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Password", 
            "Type": 3
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": "UTC", 
            "Description": "The timezone configured in the server, examples (1. UTC, 2. Asia/Jerusalem)", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Server Time Zone", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": null, 
            "Description": "If defined - connector will extract the environment from the specified event field. You can manipulate the field data using the Regex pattern field to extract specific string. In case the the extracted environment field and Siemplify environment name are not equal - you can map them in the map.json that is auto-generated on the first run, inside the <run-folder>.<run-folder> = C:\\Siemplify_Server\\Scripting\\SiemplifyConnectorExecution<Connector_Folder>", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Environment Field Name", 
            "Type": 1
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": null, 
            "Description": "If defined - the connector will implement the specific RegEx pattern on the data from \"envirnment field\" to extract specific string. For example - extract domain from sender's address: \"(?<=@)(\\S+$)\"", 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Environment Regex Pattern", 
            "Type": 1
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": "TRUE", 
            "Description": "Indicates whether to use ssl on connection or not.", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "IMAP USE SSL", 
            "Type": 0
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": "true", 
            "Description": "If checked, pull only unread mails", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Unread Emails Only", 
            "Type": 0
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": "true", 
            "Description": "If checked, mark mails as read after pulling them", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Mark Emails as Read", 
            "Type": 0
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": "false", 
            "Description": "If checked, attach the original message as eml file.", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Attach Original EML", 
            "Type": 0
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": "5", 
            "Description": "Max number of days to fetch mails since. e.g. 3", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Offset Time In Days", 
            "Type": 2
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "DefaultValue": "10", 
            "Description": "Max count of mails to pull in one cycle", 
            "Id": -1, 
            "IsMandatory": true, 
            "Mode": 2, 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Max Emails Per Cycle", 
            "Type": 2
        }, 
        {
            "CreationTimeUnixTimeInMs": 1574099687000, 
            "Name": "Proxy Server Address", 
            "ModificationTimeUnixTimeInMs": 1574099687000, 
            "Type": 2, 
            "DefaultValue": null, 
            "Description": "The address of the proxy server to use.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }, 
        {
            "CreationTimeUnixTimeInMs": 1574099687000, 
            "Name": "Proxy Username", 
            "ModificationTimeUnixTimeInMs": 1574099687000, 
            "Type": 2, 
            "DefaultValue": null, 
            "Description": "The proxy username to authenticate with.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }, 
        {
            "CreationTimeUnixTimeInMs": 1525167465721, 
            "Name": "Proxy Password", 
            "ModificationTimeUnixTimeInMs": 1525167465721, 
            "Type": 3, 
            "DefaultValue": null, 
            "Description": "The proxy password to authenticate with.", 
            "ConnectorDefinitionId": -1, 
            "Id": -1, 
            "IsMandatory": false, 
            "Mode": 2
        }
    ], 
    "ProductToVisualFamilyRecords": [], 
    "Rules": [
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1524986708109, 
            "Id": -1, 
            "ModificationTimeUnixTimeInMs": 1524986708109, 
            "RuleName": "subject: (?<=Subject: ).*", 
            "RuleType": 0
        }, 
        {
            "ConnectorDefinitionId": -1, 
            "CreationTimeUnixTimeInMs": 1524986708109, 
            "Id": -1, 
            "ModificationTimeUnixTimeInMs": 1524986708109, 
            "RuleName": "to: (?m)(?<=^To: ).*", 
            "RuleType": 0
        }
    ], 
    "Script": "# ============================================================================#\n# title           :EmailConnector.py\n# description     :This Module contain all Email connector functionality\n# author          :zivh@siemplify.co\n# date            :24-04-2018\n# python_version  :2.7\n# ============================================================================#\n\n# ============================= IMPORTS ===================================== #\nimport sys\nimport re\nimport os\nimport uuid\nimport hashlib\nimport datetime\nimport pytz\nfrom tzlocal import get_localzone\nfrom copy import deepcopy\nfrom SiemplifyUtils import convert_string_to_datetime, convert_datetime_to_unix_time,\\\n    convert_unixtime_to_datetime, dict_to_flat, unix_now, utc_now\nfrom SiemplifyConnectors import CaseInfo, SiemplifyConnectorExecution\nfrom EmailManager import EmailManager\n\n# ============================== CONSTS ===================================== #\nPRODUCT = VENDOR = \"Mail\"\nDATE_TIME_STR_FORMAT = \"%a, %d %b %Y %H:%M:%S %z\"\nDEFAULT_NAME = \"Monitored Mailbox <{0}>\"\nRULE_GENERATOR = 'Email'\nTIMESTAMP = \"timestamp.stmp\"\nFIRST_TIME_RUN_OFFSET_IN_DAYS = 5\n\nDEFAULT_REGEX_MAP = {\"urls\": \"http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+\",\n                     \"subject\": \"(?<=Subject: ).*\",\n                     \"from\": \"(?<=From: ).*\",\n                     \"to\": \"(?m)(?<=^To: ).*\"}\n\n# ============================= CLASSES ===================================== #\n\n\nclass EmailConnectorException(Exception):\n    \"\"\"\n    Email Connector Exception\n    \"\"\"\n    pass\n\n\nclass EmailConnector(object):\n\n    def __init__(self, connector_scope, email_manager, device_product_field_name, unread_only, mark_as_read, server_time_zone):\n        self.connector_scope = connector_scope\n        self.logger = connector_scope.LOGGER\n        self.email_manager = email_manager\n        self.device_product_field_name = device_product_field_name\n        self.unread_only = unread_only\n        self.mark_as_read = mark_as_read\n        self.server_time_zone = server_time_zone\n\n    @staticmethod\n    def validate_timestamp(last_run_timestamp, offset):\n        \"\"\"\n        Validate timestamp in range\n        :param last_run_timestamp: {datetime} last run timestamp\n        :param offset: {datetime} last run timestamp\n        :return: {datetime} if first run, return current time minus offset time, else return timestamp from file\n        \"\"\"\n        current_time = utc_now()\n        # Check if first run\n        if current_time - last_run_timestamp > datetime.timedelta(days=offset):\n            return current_time - datetime.timedelta(days=offset)\n        else:\n            return last_run_timestamp\n\n    # TODO: Change the function in the SiemplifyBase\n    def save_last_mail_timestamp(self, new_timestamp):\n        \"\"\"\n        Save last execution datetime as string in file\n        :param new_timestamp: {datetime} the last execution time is set to the newest message time if exists, else is set to time from file\n        \"\"\"\n        saveFilePath = os.path.join(self.connector_scope.run_folder, TIMESTAMP)\n        time_file = open(saveFilePath, 'w')\n        time_file.write(str(new_timestamp))\n        time_file.close()\n\n    def extract_event_details(self, content):\n        \"\"\"\n        Get urls, subject, from and to addresses from email body\n        :param content: {str} email body\n        :return: {dict} fields after parse.\n        \"\"\"\n        result_dictionary = {}\n        for key, regex_value in DEFAULT_REGEX_MAP.items():\n            regex_object = re.compile(regex_value)\n            all_results = regex_object.findall(content)\n            if all_results:\n                result_dictionary[key] = \";\".join([item.strip(\"<>\") for item in all_results])\n        return result_dictionary\n\n    def get_email_alerts(self, last_run):\n        \"\"\"\n        Get emails and create alerts for them.\n        :param last_run: {datetime} last execution time from file\n        :return: {[CaseInfo]} List of CaseInfos/alerts for emails.\n        \"\"\"\n        alerts = []\n        filtered_mails = []\n\n        try:\n            filtered_mails = self.email_manager.receive_mail(time_filter=last_run, only_unread=self.unread_only,\n                                                             mark_as_read=self.mark_as_read, time_zone=self.server_time_zone)\n            self.logger.info(\"Found {} emails.\".format(len(filtered_mails)))\n\n        except Exception as e:\n            self.logger.error(\"Failed to retrieve emails. Error message: {}\".format(e.message))\n            self.logger._log.exception(e)\n\n        for email in filtered_mails:\n            try:\n                email_id = email['message_id'].strip(\"<>\")\n                self.logger.info(\"Processing Email {}\".format(email_id))\n                # Generate case info for the email\n                alerts.append(self.create_case_info(email))\n\n            except Exception as e:\n                self.logger.error(\"Failed to create CaseInfo for Email {}\".format(email_id))\n                self.logger.error(\"Error Message: {}\".format(e.message))\n                self.logger._log.exception(e)\n\n        return alerts\n\n    def create_event(self, event_details, email):\n        \"\"\"\n        Create events from email data\n        :param event_details: {dict} email body data\n        :param email: {dict} All email data\n        :return: event {dict} one event from the email data\n        \"\"\"\n        # In case of an regular email - not a forwarded email\n        if email['subject'] and not email['subject'].lower().startswith(\"fwd:\"):\n            event_details['subject'] = email['subject']\n            event_details['from'] = email['sender']\n            event_details['to'] = email['to'][0]\n\n        # Add time zone\n        email_time_with_time_zone = pytz.timezone(self.server_time_zone).localize(email['date'])\n        event_details['time'] = convert_datetime_to_unix_time(email_time_with_time_zone)\n\n        event_details['device_product'] = PRODUCT\n        event_details['body'] = email['body']\n        event_details['name'] = DEFAULT_NAME.format(email['to'][0])\n\n        # Get attachments\n        event_details = self.get_email_attachments(email, event_details)\n\n        # Divide urls\n        # works if 'urls' in event_details and event_details['urls']:\n        if event_details.get('url'):\n            for index, url in enumerate(event_details['urls'].split(';')):\n                event_details[\"url_{0}\".format(index + 1)] = url\n\n        event = deepcopy(event_details)\n\n        if 'time' in event:\n            # utc_ms_time = convert_datetime_to_unix_time(event['time'])\n            utc_ms_time = event['time']\n        else:\n            utc_ms_time = unix_now()\n\n        event[\"managerReceiptTime\"] = event[\"StartTime\"] = event[\"EndTime\"] = event[\"generated_time\"] = utc_ms_time\n        # event['time'] = event['time'].isoformat()\n\n        return event\n\n    def get_email_attachments(self, email, event_details):\n        \"\"\"\n        Add attachments data to an event\n        :param email: {dict} All email data\n        :param event_details: {dict} email body data\n        :return: {dict} event with attachments info - name and md5 hash\n        \"\"\"\n        try:\n            for index, (attachment_name, attachment_value) in enumerate(email['attachments'].items()):\n                self.logger.info(\"Found attachment {}\".format(attachment_name))\n                event_details[\"file_{0}_name\".format(index+1)] = attachment_name\n                event_details[\"file_{0}_md5\".format(index+1)] = hashlib.md5(attachment_value).hexdigest()\n\n        except Exception as e:\n            self.logger.error(\"An error occurred during extracting the attachments.\")\n            self.logger._log.exception(e)\n\n        return event_details\n\n    def create_case_info(self, email):\n        \"\"\"\n        Get alerts from Email\n        :param email: {dict} An email data\n        :return: {CaseInfo} case\n        \"\"\"\n        # Validate email message id exists\n        try:\n            email_id = email['message_id'].strip(\"<>\")\n        except:\n            email_id = str(uuid.uuid4())\n\n        try:\n            case_info = CaseInfo()\n            # Not create case if email body is empty\n            if email['body']:\n                event_details = dict_to_flat(self.extract_event_details(email['body']))\n\n                # Create security event\n                event = self.create_event(event_details, email)\n\n                self.logger.info(\"Creating Case for Email {}\".format(email_id))\n\n                # Create the CaseInfo\n                try:\n                    case_info.name = DEFAULT_NAME.format(email['to'][0])\n                    case_info.rule_generator = RULE_GENERATOR\n                    case_info.start_time = event[\"StartTime\"]\n                    case_info.end_time = event[\"EndTime\"]\n                    case_info.identifier = email_id\n                    case_info.ticket_id = case_info.identifier\n                    case_info.priority = 40  # Defaulting to Low.\n                    case_info.device_vendor = VENDOR\n                    case_info.device_product = PRODUCT\n                    case_info.display_id = case_info.identifier\n                    case_info.environment = self.connector_scope.context.connector_info.environment\n                    case_info.events = [event]\n\n                except KeyError as e:\n                    raise KeyError(\"Mandatory key is missing: {}. Skipping email.\".format(e.message.encode('utf-8')))\n\n        except Exception as e:\n            self.logger.error(\"An error occurred. Skipping email.\")\n            self.logger._log.exception(e)\n\n        return case_info\n\n\ndef test():\n    \"\"\"\n    Test execution - Email Connector\n    \"\"\"\n    connector_scope = SiemplifyConnectorExecution()\n    connector_scope.LOGGER.info(\"=======Starting Email Connector TEST.=======\")\n\n    try:\n        connector_scope.LOGGER.info(\"Testing - Login to IMAP\")\n        from_address = connector_scope.parameters[\"Sender's address\"]\n        imap_host = connector_scope.parameters['IMAP Server Address']\n        imap_port = str(connector_scope.parameters['IMAP Port'])\n        username = connector_scope.parameters['Username']\n        password = connector_scope.parameters['Password']\n        server_time_zone = connector_scope.parameters['Server Time Zone']\n        first_run_timestamp = int(connector_scope.parameters.get(\n            'First Time Run Offset In Days')) or FIRST_TIME_RUN_OFFSET_IN_DAYS\n\n        use_ssl = connector_scope.parameters['IMAP USE SSL'].lower() == 'true'\n        unread_only = connector_scope.parameters['Unread Emails Only'].lower() == 'true'\n        mark_as_read = False\n\n        connector_scope.LOGGER.info(\"Connecting to Email manager\")\n        email_manager = EmailManager(from_address)\n\n        # IMAP Login\n        email_manager.login_imap(host=imap_host, port=imap_port, username=username, password=password, use_ssl=use_ssl)\n\n        email_connector = EmailConnector(connector_scope, email_manager, PRODUCT, unread_only, mark_as_read, server_time_zone)\n\n        # Fix first time run\n        last_run_time = email_connector.validate_timestamp(connector_scope.fetch_timestamp(datetime_format=True),\n                                                           first_run_timestamp)\n\n        # Get alerts\n        connector_scope.LOGGER.info(\"Testing - Collecting emails.\")\n        cases = email_connector.get_email_alerts(last_run_time)\n        connector_scope.LOGGER.info(\"Testing - Completed processing emails.\")\n\n        connector_scope.LOGGER.info(\"=======Email Connector TEST Finish.=======\")\n\n        # Return data\n        connector_scope.return_test_result(True, {})\n\n    except Exception as e:\n        raise Exception(e.message)\n\n\ndef main():\n    \"\"\"\n    Main execution - Email Connector\n    \"\"\"\n    connector_scope = SiemplifyConnectorExecution()\n    output_variables = {}\n    log_items = []\n\n    connector_scope.LOGGER.info(\"=======Starting Email Connector.=======\")\n\n    try:\n        from_address = connector_scope.parameters[\"Sender's address\"]\n        imap_host = connector_scope.parameters['IMAP Server Address']\n        imap_port = str(connector_scope.parameters['IMAP Port'])\n        username = connector_scope.parameters['Username']\n        password = connector_scope.parameters['Password']\n        server_time_zone = connector_scope.parameters['Server Time Zone']\n        first_run_timestamp = int(connector_scope.parameters.get('First Time Run Offset In Days')) or \\\n                              FIRST_TIME_RUN_OFFSET_IN_DAYS\n\n        use_ssl = connector_scope.parameters['IMAP USE SSL'].lower() == 'true'\n        unread_only = connector_scope.parameters['Unread Emails Only'].lower() == 'true'\n        mark_as_read = connector_scope.parameters['Mark Emails as Read'].lower() == 'true'\n\n        connector_scope.LOGGER.info(\"Connecting to Email manager\")\n        email_manager = EmailManager(from_address)\n\n        connector_scope.LOGGER.info(\"Login to IMAP\")\n        email_manager.login_imap(host=imap_host, port=imap_port, username=username, password=password, use_ssl=use_ssl)\n\n        email_connector = EmailConnector(connector_scope, email_manager, PRODUCT, unread_only, mark_as_read, server_time_zone)\n\n        # Fix first time run\n        connector_scope.LOGGER.info(\"Calculating last run time.\")\n        # CR: Work with UTC timezone - UTC is default in fetch_timestamp\n        last_run_time = connector_scope.fetch_timestamp(datetime_format=True)\n        last_calculated_run_time = email_connector.validate_timestamp(last_run_time, first_run_timestamp)\n\n        # Get alerts\n        connector_scope.LOGGER.info(\"Collecting emails.\")\n        cases = email_connector.get_email_alerts(last_calculated_run_time)\n\n        connector_scope.LOGGER.info(\"Completed processing emails.\")\n\n        # Get last successful execution time.\n        if cases:\n            # Last execution time is set to the newest message time\n            time = convert_unixtime_to_datetime(cases[0].events[0]['EndTime'])\n            # CR: Work with UTC.\n            # Add time zone to datetime\n            # time_zone = get_localzone().zone\n            # new_last_run_time = time.astimezone(pytz.timezone(time_zone))\n            new_last_run_time = time\n        else:\n            new_last_run_time = last_calculated_run_time\n\n        # update last execution time\n        email_connector.save_last_mail_timestamp(new_last_run_time)\n\n        connector_scope.LOGGER.info(\"=======Email Connector Finish.=======\")\n\n        # Return data\n        connector_scope.return_package(cases, output_variables, log_items)\n\n    except Exception as e:\n        connector_scope.LOGGER.error(e.message)\n        connector_scope.LOGGER._log.exception(e)\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2 or sys.argv[1] == 'True':\n        print \"Main execution started\"\n        main()\n    else:\n        print \"Test execution started\"\n        test()\n", 
    "SimulationUseCases": {
        "CasesForUseCase": [], 
        "UseCaseName": null
    }, 
    "Version": 1
}