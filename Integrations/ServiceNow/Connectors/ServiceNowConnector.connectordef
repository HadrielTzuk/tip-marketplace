{
    "CreationTimeUnixTimeInMs": 1532871487965, 
    "Creator": "Admin", 
    "Description": "Fetching incidents from ServiceNow to Siemplify",
    "Id": -1,
    "Integration": "ServiceNow",
    "IsConnectorRulesSupported": false,
    "IsCustom": false,
    "IsEnabled": true,
    "MappingRules": [],
    "ModificationTimeUnixTimeInMs": 1532871487965,
    "Name": "ServiceNow Connector",
    "Parameters": [
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": "Product Name",
            "Description": "The field name used to determine the device product",
            "Id": -1,
            "IsMandatory": true,
            "IsAdvanced": true,
            "Mode": 0,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "DeviceProductField",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": "sys_class_name",
            "Description": "The field name used to determine the event name (sub-type)",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 0,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "EventClassId",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": "60",
            "Description": "The timeout limit (in seconds) for the python process running current script",
            "Id": -1,
            "IsMandatory": true,
            "IsAdvanced": true,
            "Mode": 0,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "PythonProcessTimeout",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": null,
            "Description": "The field name used to determine the rule generator.",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": false,
            "Mode": 0,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "Rule Generator",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": null,
            "Description": "https://{dev-instance}.service-now.com/api/now/v1/",
            "Id": -1,
            "IsMandatory": true,
            "IsAdvanced": false,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "Api Root",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": "incident",
            "Description": "This parameter is defining what API root ServiceNow integration is going to use for actions that revolve around incidents. By default the integration uses the “table/incident” path. ",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "Incident Table",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": null,
            "Description": "",
            "Id": -1,
            "IsMandatory": true,
            "IsAdvanced": false,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "Username",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": null,
            "Description": "",
            "Id": -1,
            "IsMandatory": true,
            "IsAdvanced": false,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "Password",
            "Type": 3
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": true,
            "Description": "If enabled, verify the SSL certificate for the connection to the ServiceNow server is valid.",
            "Id": -1,
            "IsMandatory": true,
            "IsAdvanced": false,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "Verify SSL",
            "Type": 0
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": "",
            "Description": "Client ID of Service Now application. Required for Oauth authentication.",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "Client ID",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": "",
            "Description": "Client Secret of Service Now application. Required for Oauth authentication.",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "Client Secret",
            "Type": 3
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": "",
            "Description": "Refresh token for Service Now application. Required for Oauth authentication.",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "Refresh Token",
            "Type": 3
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": false,
            "Description": "If enabled, integration will use Oauth authentication. Parameters “Client ID“, “Client Secret“ and “Refresh Token“ are mandatory.",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "Use Oauth Authentication",
            "Type": 0
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": "5",
            "Description": "Fetch incidents from 'x' days backwards. e.g. 3",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": false,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "Days Backwards",
            "Type": 1
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": "10",
            "Description": "Fetch max 'x' incidents. e.g. 10",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": false,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "Max Incidents Per Cycle",
            "Type": 1
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": "UTC",
            "Description": "The timezone configured in the server, ex. UTC, Asia/Jerusalem etc.",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "Server Time Zone",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": null,
            "Description": "The environments (domains) to ingest into Siemplify, comma separated list (env1,env2)",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": false,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "Environments Whitelist",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": null,
            "Description": "The table to fetch from. e.g. incident",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "Table Name",
            "Type": 2
        },
        {
            "ConnectorDefinitionId": -1,
            "CreationTimeUnixTimeInMs": 1532871487965,
            "DefaultValue": null,
            "Description": "The name of the event in Siemplify. e.g. ServiceNowEvent",
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2,
            "ModificationTimeUnixTimeInMs": 1532871487965,
            "Name": "Event Name",
            "Type": 2
        },
        {
            "CreationTimeUnixTimeInMs": 1574099687000,
            "Name": "Proxy Server Address",
            "ModificationTimeUnixTimeInMs": 1574099687000,
            "Type": 2,
            "DefaultValue": null,
            "Description": "The address of the proxy server to use.",
            "ConnectorDefinitionId": -1,
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2
        },
        {
            "CreationTimeUnixTimeInMs": 1574099687000,
            "Name": "Proxy Username",
            "ModificationTimeUnixTimeInMs": 1574099687000,
            "Type": 2,
            "DefaultValue": null,
            "Description": "The proxy username to authenticate with.",
            "ConnectorDefinitionId": -1,
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2
        },
        {
            "CreationTimeUnixTimeInMs": 1525167465721,
            "Name": "Proxy Password",
            "ModificationTimeUnixTimeInMs": 1525167465721,
            "Type": 3,
            "DefaultValue": null,
            "Description": "The proxy password to authenticate with.",
            "ConnectorDefinitionId": -1,
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2
        },
        {
            "CreationTimeUnixTimeInMs": 1525167465721,
            "Name": "Get User Information",
            "ModificationTimeUnixTimeInMs": 1525167465721,
            "Type": 0,
            "DefaultValue": false,
            "Description": "If enabled, connector will additionally retrieve information about the users related to the incident.",
            "ConnectorDefinitionId": -1,
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": true,
            "Mode": 2
        },
        {
            "CreationTimeUnixTimeInMs": 1525167465721,
            "Name": "Use whitelist as a blacklist",
            "ModificationTimeUnixTimeInMs": 1525167465721,
            "Type": 0,
            "DefaultValue": false,
            "Description": "If enabled, whitelist will be used as a blacklist.",
            "ConnectorDefinitionId": -1,
            "Id": -1,
            "IsMandatory": false,
            "IsAdvanced": false,
            "Mode": 2
        }
    ],
    "ProductToVisualFamilyRecords": [], 
    "Rules": [], 
    "Script": "# ============================================================================#\n# title           :ServiceNowConnector.py\n# description     :This Module contain all ServiceNow connector functionality\n# author          :zivh@siemplify.co\n# date            :26-07-2018\n# python_version  :2.7\n# ============================================================================#\n\n# ============================= IMPORTS ===================================== #\nimport sys\nimport uuid\nimport datetime\nimport arrow\nfrom SiemplifyUtils import utc_now, convert_string_to_datetime\nfrom SiemplifyConnectors import CaseInfo, SiemplifyConnectorExecution\nfrom ServiceNowManager import ServiceNowManager\n\n# ============================== CONSTS ===================================== #\nPRODUCT = VENDOR = \"Service Now\"\nDEFAULT_DAYS_BACKWARDS = 2\nMAX_INCIDENTS_PER_CYCLE = 10\nDEFAULT_NAME = 'ServiceNow'\nRULE_GENERATOR = 'Service Now System'\nMSG_ID_ERROR_MSG = \"Can't get incident id\"\n\nHIGH_PRIORITY = 80\nMEDIUM_PRIORITY = 60\nLOW_PRIORITY = 40\n\n# ============================= CLASSES ===================================== #\n\n\nclass ServiceNowConnectorException(Exception):\n    \"\"\"\n    Service Now Connector Exception\n    \"\"\"\n    pass\n\n\nclass ServiceNowConnector(object):\n\n    def __init__(self, connector_scope, sn_manager, max_incidents_per_cycle, server_time_zone):\n        self.connector_scope = connector_scope\n        self.logger = connector_scope.LOGGER\n        self.sn_manager = sn_manager\n        self.max_incidents_per_cycle = max_incidents_per_cycle\n        self.server_time_zone = server_time_zone\n\n    @staticmethod\n    def validate_timestamp(last_run_timestamp, offset):\n        \"\"\"\n        Validate timestamp in range\n        :param last_run_timestamp: {datetime} last run timestamp\n        :param offset: {datetime} last run timestamp\n        :return: {datetime} if first run, return current time minus offset time, else return timestamp from file\n        \"\"\"\n        current_time = utc_now()\n        # Check if first run\n        if current_time - last_run_timestamp > datetime.timedelta(days=offset):\n            return current_time - datetime.timedelta(days=offset)\n        else:\n            return last_run_timestamp\n\n    def get_incidents(self, last_run):\n        \"\"\"\n        Get tickets since last success time.\n        :param last_run: {datetime}\n        :return:\n\n        \"\"\"\n        sn_last_time_format = self.sn_manager.convert_datetime_to_sn_format(last_run)\n        tickets_ids = []\n        incidents = []\n\n        try:\n            # Get tickets since last success time.\n            tickets_ids = self.sn_manager.get_incident_ids_by_time_filter(sn_last_time_format)\n\n        except Exception as e:\n            self.logger.exception(e)\n\n        if tickets_ids:\n            # Tickets limit per cycle - Default - The 10 oldest incidents.\n            for incident_id in tickets_ids[:self.max_incidents_per_cycle]:\n                try:\n                    incident_dict = self.sn_manager.get_ticket_by_id(incident_id)['result']\n                    # Check if incident is already taken, if yes - continue\n                    if self.validate_incident_time(last_run, incident_dict):\n                            continue\n                    incidents.append(incident_dict)\n\n                except Exception as e:\n                    self.logger.error(\"Failed to retrieve incident data. Error message: {}\".format(e.message))\n                    self.logger.exception(e)\n\n            self.logger.info(\"Found {0} incidents since {1}.\".format(len(incidents), unicode(sn_last_time_format).encode('utf-8')))\n\n        return incidents\n\n    def validate_incident_time(self, last_run_time, incident_dict):\n        \"\"\"\n        Compare incident time to connector last run time to make sure incidents are not taken more than once.\n        Base on the ServiceNow Api, incident fetch without time zone\n        :param last_run_time: {datetime} last execution time from file\n        :param incident_dict: {Incident object}\n        :return: {Boolean}\n        \"\"\"\n        # compare full dates\n        incident_time = convert_string_to_datetime(incident_dict['opened_at'], timezone_str=self.server_time_zone)\n        # Checking if incident is already taken, if yes- True.\n        if incident_time <= last_run_time:\n            return True\n        return False\n\n    def create_event(self, incident):\n        \"\"\"\n        Create events from incident data\n        :param incident: {dict} All incident data\n        :return: event {dict} one event from the incident data\n        \"\"\"\n        # TODO: all ticket raw data should be ingested to the event\n        event_details = {}\n        for key, value in incident.items():\n            if value and not isinstance(value, dict):\n                event_details[key] = value\n\n        # Incident date is in UTC time, save time in unix.\n        # * 1000 to convert unix time to millisecond.\n        event_details['time'] = arrow.get(incident.get('opened_at', 1)).timestamp * 1000\n        event_details[\"managerReceiptTime\"] = event_details[\"StartTime\"] = event_details[\"EndTime\"] = event_details[\n            \"generated_time\"] = event_details['time']\n\n        event_details['vendor'] = VENDOR\n        event_details['device_product'] = PRODUCT\n\n        try:\n            event_details['name'] = incident['number']\n        except (IndexError, KeyError) as e:\n            self.logger.error(\"Can't display incident number. {0}\".format(e))\n            event_details['name'] = DEFAULT_NAME\n\n        return event_details\n\n    @staticmethod\n    def map_priority(sn_priority):\n        \"\"\"\n        Mapping ServiceNow priority to siemplify priority\n        :param sn_priority: {string} '1, 2 or 3' (1=high, 2=medium, 3=low)\n        :return: {int} (40=low, 60=medium, 80=high)\n        \"\"\"\n        if sn_priority == '1':\n            siemplify_priority = HIGH_PRIORITY\n        elif sn_priority == '2':\n            siemplify_priority = MEDIUM_PRIORITY\n        else:\n            siemplify_priority = LOW_PRIORITY\n\n        return siemplify_priority\n\n    def create_case_info(self, incident, event, environment):\n        \"\"\"\n        Get alerts from Incident\n        :param incident: {dict} An incident data\n        :param event: {dict} one event from the incident data\n        :param environment:\n        :return: {CaseInfo} case\n        \"\"\"\n        # Validate incident number exists\n        try:\n            incident_number = incident['number']\n        except Exception as e:\n            incident_number = '{0}-{1}'.format(MSG_ID_ERROR_MSG, str(uuid.uuid4()))\n            self.logger.error(\"Found incident, cannot get its number. {0}\".format(str(e)))\n\n        case_info = CaseInfo()\n        self.logger.info(\"Creating Case for incident {}\".format(incident_number))\n        # Create the CaseInfo\n        try:\n            case_info.name = event.get(\"name\", DEFAULT_NAME)\n            case_info.rule_generator = RULE_GENERATOR\n            case_info.start_time = event.get(\"time\", 1)\n            case_info.end_time = event.get(\"time\", 1)\n            case_info.identifier = incident_number\n            case_info.ticket_id = case_info.identifier\n            # Priority mapped from service now values to siemplify values\n            case_info.priority = self.map_priority(incident.get('urgency'))\n            case_info.device_vendor = VENDOR\n            case_info.device_product = PRODUCT\n            case_info.display_id = case_info.identifier\n            case_info.environment = environment\n            case_info.events = [event]\n\n        except KeyError as e:\n            raise KeyError(\"Mandatory key is missing: {}. Skipping Incident.\".format(unicode(e.message.encode('utf-8'))))\n\n        return case_info\n\n\ndef test():\n    \"\"\"\n    Test execution - ServiceNow Connector\n    \"\"\"\n    connector_scope = SiemplifyConnectorExecution()\n    connector_scope.LOGGER.info(\"=======Starting ServiceNow Connector TEST.=======\")\n\n    connector_scope.LOGGER.info(\"Testing - Connecting to ServiceNow\")\n    # Configurations.\n    api_root = connector_scope.parameters['Api Root']\n    username = connector_scope.parameters['Username']\n    password = connector_scope.parameters['Password']\n    service_now_manager = ServiceNowManager(api_root, username, password, default_incident_table)\n\n    first_run_timestamp = int(connector_scope.parameters.get('Days Backwards', DEFAULT_DAYS_BACKWARDS))\n    max_incidents_per_cycle = int(connector_scope.parameters.get('Max Incidents Per Cycle', MAX_INCIDENTS_PER_CYCLE))\n    server_time_zone = connector_scope.parameters.get('Server Time Zone', 'UTC')\n    environment = connector_scope.context.connector_info.environment\n\n    servicenow_connector = ServiceNowConnector(connector_scope, service_now_manager, max_incidents_per_cycle, server_time_zone)\n\n    # Fix first time run\n    last_run_time = connector_scope.fetch_timestamp(datetime_format=True)\n    last_calculated_run_time = servicenow_connector.validate_timestamp(last_run_time, first_run_timestamp)\n    connector_scope.LOGGER.info(\"Calculating connector last run time. Last run time is: {0}\".format(last_calculated_run_time))\n\n    # Get alerts\n    connector_scope.LOGGER.info(\"Testing - Collecting Incidents.\")\n    incidents = servicenow_connector.get_incidents(last_calculated_run_time)\n    cases = []\n    for incident in incidents:\n        # Create security event\n        event = servicenow_connector.create_event(incident)\n        # Create case info\n        case = servicenow_connector.create_case_info(incident, event, environment)\n\n        is_overflow = False\n        try:\n            # Check if alert overflow\n            is_overflow = connector_scope.is_overflowed_alert(\n                environment=environment,\n                alert_identifier=str(case.ticket_id),\n                alert_name=str(case.rule_generator),\n                product=str(case.device_product)\n            )\n        except Exception as e:\n            connector_scope.LOGGER.error(\"Check if alert is overflow failed. Error: {0}.\".format(e))\n\n        if is_overflow:\n            # Skipping this alert (and do not ingest it to siemplify)\n            connector_scope.LOGGER.info(\n                \"{alert_name}-{alert_identifier}-{environment}-{product} found as overflow alert. Skipping.\"\n                .format(alert_name=str(case.rule_generator),\n                        alert_identifier=str(case.ticket_id),\n                        environment=str(environment),\n                        product=str(case.device_product)))\n        else:\n            # Ingest case to siemplify\n            cases.append(case)\n\n    connector_scope.LOGGER.info(\"Testing - Completed processing incidents.\")\n    connector_scope.LOGGER.info(\"Create {} cases.\".format(len(cases)))\n    connector_scope.LOGGER.info(\"=======ServiceNow Connector TEST Finish.=======\")\n\n    # Return data\n    connector_scope.return_test_result(True, {})\n\n\ndef main():\n    \"\"\"\n    Main execution - ServiceNow Connector\n    \"\"\"\n    connector_scope = SiemplifyConnectorExecution()\n    output_variables = {}\n    log_items = []\n\n    connector_scope.LOGGER.info(\"=======Starting ServiceNow Connector.=======\")\n\n    try:\n        # Configurations.\n        api_root = connector_scope.parameters['Api Root']\n        username = connector_scope.parameters['Username']\n        password = connector_scope.parameters['Password']\n        service_now_manager = ServiceNowManager(api_root, username, password, default_incident_table)\n\n        first_run_timestamp = int(connector_scope.parameters.get('Days Backwards', DEFAULT_DAYS_BACKWARDS))\n        max_incidents_per_cycle = int(\n            connector_scope.parameters.get('Max Incidents Per Cycle', MAX_INCIDENTS_PER_CYCLE))\n        server_time_zone = connector_scope.parameters.get('Server Time Zone', 'UTC')\n        environment = connector_scope.context.connector_info.environment\n\n        servicenow_connector = ServiceNowConnector(connector_scope, service_now_manager, max_incidents_per_cycle,\n                                                   server_time_zone)\n\n        # Fix first time run\n        last_run_time = connector_scope.fetch_timestamp(datetime_format=True)\n        last_calculated_run_time = servicenow_connector.validate_timestamp(last_run_time, first_run_timestamp)\n        connector_scope.LOGGER.info(\n            \"Calculating connector last run time. Last run time is: {0}\".format(last_calculated_run_time))\n\n        # Get alerts\n        connector_scope.LOGGER.info(\"Collecting Incidents.\")\n        incidents = servicenow_connector.get_incidents(last_calculated_run_time)\n        cases = []\n        for incident in incidents:\n            try:\n                # Create security event\n                event = servicenow_connector.create_event(incident)\n            except Exception as e:\n                # If the event creation fails, event is an empty dict\n                event = {}\n                connector_scope.LOGGER.error(\"Failed to create event. {0}\".format(str(e)))\n                connector_scope.LOGGER.exception(e)\n\n            try:\n                # Create case info\n                case = servicenow_connector.create_case_info(incident, event, environment)\n\n                is_overflow = False\n                try:\n                    # Check if alert overflow\n                    is_overflow = connector_scope.is_overflowed_alert(\n                        environment=environment,\n                        alert_identifier=str(case.ticket_id),\n                        alert_name=str(case.rule_generator),\n                        product=str(case.device_product)\n                    )\n                except Exception as e:\n                    connector_scope.LOGGER.error(\"Check if alert is overflow failed. Error: {0}.\".format(e))\n\n                if is_overflow:\n                    # Skipping this alert (and dot ingest it to siemplify)\n                    connector_scope.LOGGER.info(\"{alert_name}-{alert_identifier}-{environment}-{product} found as overflow alert. Skipping\"\n                                                .format(alert_name=str(case.rule_generator),\n                                                        alert_identifier=str(case.ticket_id),\n                                                        environment=environment,\n                                                        product=str(case.device_product)))\n                else:\n                    # Ingest the case to siemplify\n                    cases.append(case)\n\n            except Exception as e:\n                connector_scope.LOGGER.error(\"Failed to create CaseInfo\")\n                connector_scope.LOGGER.error(\"Error Message: {}\".format(e.message))\n                connector_scope.LOGGER.exception(e)\n\n        connector_scope.LOGGER.info(\"Completed processing incidents.\")\n\n        # Get last successful execution time.\n        if cases:\n            # Sort the cases by the end time of each case.\n            cases = sorted(cases, key=lambda case: case.end_time)\n            # Last execution time is set to the newest message time\n            new_last_run_time = cases[-1].end_time\n        else:\n            # last_calculated_run_time is datetime object. Convert it to milliseconds timestamp.\n            new_last_run_time = arrow.get(last_calculated_run_time).timestamp*1000\n\n        # update last execution time\n        connector_scope.save_timestamp(new_timestamp=new_last_run_time)\n\n        connector_scope.LOGGER.info(\"Create {} cases.\".format(len(cases)))\n        connector_scope.LOGGER.info(\"=======ServiceNow Connector Finish.=======\")\n\n        # Return data\n        connector_scope.return_package(cases, output_variables, log_items)\n\n    except Exception as e:\n        connector_scope.LOGGER.error(e.message)\n        connector_scope.LOGGER.exception(e)\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2 or sys.argv[1] == 'True':\n        print \"Main execution started\"\n        main()\n    else:\n        print \"Test execution started\"\n        test()\n",
    "SimulationUseCases": {
        "CasesForUseCase": [], 
        "UseCaseName": null
    }, 
    "Version": 1
}